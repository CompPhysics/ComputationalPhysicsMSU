<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Computational Physics: Object-orientation in Fortran">

<title>Computational Physics: Object-orientation in Fortran</title>


<style type="text/css">
/* blueish style */

/* Color definitions:  http://www.december.com/html/spec/color0.html
   CSS examples:       http://www.w3schools.com/css/css_examples.asp */

body {
  margin-top: 1.0em;
  background-color: #ffffff;
  font-family: Helvetica, Arial, FreeSans, san-serif;
  color: #000000;
}
h1 { font-size: 1.8em; color: #1e36ce; }
h2 { font-size: 1.6em; color: #1e36ce; }
h3 { font-size: 1.4em; color: #1e36ce; }
a { color: #1e36ce; text-decoration:none; }
tt { font-family: "Courier New", Courier; }
/* pre style removed because it will interfer with pygments */
p { text-indent: 0px; }
hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
p.caption { width: 80%; font-style: normal; text-align: left; }
hr.figure { border: 0; width: 80%; border-bottom: 1px solid #aaa}

div { text-align: justify; text-justify: inter-word; }
</style>


</head>

<!-- tocinfo
{'highest level': 2,
 'sections': [('Introduction', 2, None, '___sec0'),
              ('Objects in Fortran 90/95/2003', 2, None, '___sec1'),
              ('Polymorphism in Fortran 2003', 2, None, '___sec2'),
              ('Procedure Polymorphism', 2, None, '___sec3'),
              ('Procedure Polymorphism with Type-Bound Procedures',
               2,
               None,
               '___sec4'),
              ('Inheritance and Type-Bound Procedures', 2, None, '___sec5'),
              ('Procedure Overriding', 2, None, '___sec6'),
              ('Functions as Type-Bound Procedures', 2, None, '___sec7'),
              ('Information Hiding', 2, None, '___sec8'),
              ('Type Overloading', 2, None, '___sec9'),
              ('Conclusion', 2, None, '___sec10')]}
end of tocinfo -->

<body>

    
<!-- ------------------- main content ---------------------- -->



<center><h1>Computational Physics: Object-orientation in Fortran</h1></center>  <!-- document title -->

<p>
<!-- author(s): Morten Hjorth-Jensen  Email morten.hjorth-jensen@fys.uio.no -->

<center>
<b>Morten Hjorth-Jensen  Email morten.hjorth-jensen@fys.uio.no</b> [1, 2]
</center>

<p>
<!-- institution(s) -->

<center>[1] <b>Department of Physics, University of Oslo</b></center>
<center>[2] <b>Department of Physics and Astronomy and National Superconducting Cyclotron Laboratory, Michigan State University</b></center>
<br>
<p>
<center><h4>2017</h4></center> <!-- date -->
<br>

<h2 id="___sec0">Introduction </h2>

<p>
Polymorphism is a term used in software development to describe a
variety of techniques employed by programmers to create flexible and
reusable software components. The term is Greek and it loosely
translates to "many forms".

<p>
In programming languages, a polymorphic object is an entity, such as a
variable or a procedure, that can hold or operate on values of
differing types during the program's execution. Because a polymorphic
object can operate on a variety of values and types, it can also be
used in a variety of programs, sometimes with little or no change by
the programmer. The idea of write once, run many, also known as code
reusability, is an important characteristic to the programming
paradigm known as Object-Oriented Programming (OOP).

<p>
OOP describes an approach to programming where a program is viewed as
a collection of interacting, but mostly independent software
components. These software components are known as objects in OOP and
they are typically implemented in a programming language as an entity
that encapsulates both data and procedures.

<h2 id="___sec1">Objects in Fortran 90/95/2003 </h2>

<p>
A Fortran 90/95 module can be viewed as an object because it can
encapsulate both data and procedures. Fortran 2003 (F2003) added the
ability for a derived type to encapsulate procedures in addition to
data. So, by definition, a derived type can now be viewed as an object
as well in F2003.

<p>
F2003 also introduced type extension to its derived types. This
feature allows F2003 programmers to take advantage of one of the more
powerful OOP features known as inheritance. Inheritance allows code
reusability through an implied inheritance link in which leaf objects,
known as children, reuse components from their parent and ancestor
objects. For example,
<p>

<!-- code=fortran (!bc fcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">type </span><span style="color: #008000">shape</span>
<span style="color: #008000">        </span><span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> color
        <span style="color: #B00040">logical</span> <span style="color: #008000; font-weight: bold">::</span> filled
        <span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> x
        <span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> y
<span style="color: #008000; font-weight: bold">end type </span><span style="color: #008000">shape</span>
<span style="color: #008000; font-weight: bold">type</span>, <span style="color: #008000; font-weight: bold">EXTENDS</span> ( <span style="color: #008000">shape</span> ) <span style="color: #008000; font-weight: bold">::</span> rectangle
        <span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> length
        <span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> width
<span style="color: #008000; font-weight: bold">end type </span>rectangle
<span style="color: #008000; font-weight: bold">type</span>, <span style="color: #008000; font-weight: bold">EXTENDS</span> ( rectangle ) <span style="color: #008000; font-weight: bold">::</span> square
<span style="color: #008000; font-weight: bold">end type </span>square
</pre></div>
<p>
In the example above, we have a square type that inherits components
from rectangle which inherits components from shape. The programmer
indicates the inheritance relationship with the EXTENDS keyword
followed by the name of the parent type in parentheses. A type that
EXTENDS another type is known as a type extension (e.g., rectangle is
a type extension of shape, square is a type extension of rectangle and
shape). A type without any EXTENDS keyword is known as a base type
(e.g., shape is a base type).

<p>
A type extension inherits all of the components of its parent (and
ancestor) types. A type extension can also define additional
components as well. For example, rectangle has a length and width
component in addition to the color, filled, x, and y components that
were inherited from shape. The square type, on the other hand,
inherits all of the components from rectangle and shape, but does not
define any components specific to square objects. Below is an example
on how we may access the color component of square:

<p>

<!-- code=fortran (!bc fcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">type</span>(square) <span style="color: #008000; font-weight: bold">::</span> sq           <span style="color: #408080; font-style: italic">! declare sq as a square object</span>

sq%color                     <span style="color: #408080; font-style: italic">! access color component for sq</span>
sq%rectangle%color           <span style="color: #408080; font-style: italic">! access color component for sq</span>
sq%reactangle%<span style="color: #008000">shape</span>%color    <span style="color: #408080; font-style: italic">! access color component for sq</span>
</pre></div>
<p>
Note the three different ways for accessing the color component for
sq. A type extension includes an implicit component with the same name
and type as its parent type. This can come in handy when the
programmer wants to operate on components specific to a parent
type. It also helps illustrate an important relationship between the
child and parent types.

<p>
We often say the child and parent types have a "is a"
relationship. Using our shape example above, we can say "a square is a
rectangle", "a rectangle is a shape", "a square is a shape", and "a
shape is a base type". We can also apply this relationship to the type
itself (e.g., "a shape is a shape", "a rectangle is a rectangle", and
"a square is a square").

<p>
Note that the "is a" relationship does not imply the converse. A
rectangle is a shape, but a shape is not a rectangle since there are
components found in rectangle that are not found in
shape. Furthermore, a rectangle is not a square because square has a
component not found in rectangle; the implicit rectangle parent
component.

<h2 id="___sec2">Polymorphism in Fortran 2003 </h2>
<hr>

<p>
The "is a" relationship also helps us visualize how polymorphic
variables interact with type extensions. The CLASS keyword allows
F2003 programmers to create polymorphic variables. A polymorphic
variable is a variable whose data type is dynamic at runtime. It must
be a pointer variable, allocatable variable, or a dummy
argument. Below is an example:
<p>

<!-- code=fortran (!bc fcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">class</span>(<span style="color: #008000">shape</span>), <span style="color: #008000; font-weight: bold">pointer</span> <span style="color: #008000; font-weight: bold">::</span> sh
</pre></div>
<p>
In the example above, the sh object can be a pointer to a shape or any
of its type extensions. So, it can be a pointer to a shape, a
rectangle, a square, or any future type extension of shape. As long as
the type of the pointer target "is a" shape, sh can point to it.

<p>
There are two basic types of polymorphism: procedure polymorphism and
data polymorphism. Procedure polymorphism deals with procedures that
can operate on a variety of data types and values. Data polymorphism
deals with program variables that
can store and operate on a variety of data types and values.

<h2 id="___sec3">Procedure Polymorphism </h2>

<p>
Procedure polymorphism occurs when a procedure, such as a function or
a subroutine, can take a variety of data types as arguments. This is
accomplished in F2003 when a procedure has one or more dummy arguments
declared with the CLASS keyword. For example,

<p>

<!-- code=fortran (!bc fcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">subroutine </span>setColor(sh, color)
<span style="color: #008000; font-weight: bold">class</span>(<span style="color: #008000">shape</span>) <span style="color: #008000; font-weight: bold">::</span> sh
<span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> color
sh%color <span style="color: #666666">=</span> color
<span style="color: #008000; font-weight: bold">end subroutine </span>setColor
</pre></div>
<p>
The setColor subroutine takes two arguments, sh and color. The sh
dummy argument is polymorphic, based on the usage of class(shape). The
subroutine can operate on objects that satisfy the "is a" shape
relationship. So, setColor can be called with a shape, rectangle,
square, or any future type extension of shape. However, by default,
only those components found in the declared type of an object are
accessible. For example, shape is the declared type of sh. Therefore,
you can only access the shape components, by default, for sh in
setColor (i.e., sh%color, sh%filled, sh%x, sh%y). If the programmer
needs to access the components of the dynamic type of an object (e.g.,
sh%length when sh is a rectangle), then they can use the F2003 SELECT
TYPE construct. The following example illustrates how a SELECT TYPE
construct can access the components of a dynamic type of an object:

<p>

<!-- code=fortran (!bc fcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">subroutine </span>initialize(sh, color, filled, x, y, length, width)
<span style="color: #408080; font-style: italic">! initialize shape objects</span>
<span style="color: #008000; font-weight: bold">class</span>(<span style="color: #008000">shape</span>) <span style="color: #008000; font-weight: bold">::</span> sh
<span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> color
<span style="color: #B00040">logical</span> <span style="color: #008000; font-weight: bold">::</span> filled
<span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> x
<span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> y
<span style="color: #B00040">integer</span>, <span style="color: #008000; font-weight: bold">optional</span> <span style="color: #008000; font-weight: bold">::</span> length
<span style="color: #B00040">integer</span>, <span style="color: #008000; font-weight: bold">optional</span> <span style="color: #008000; font-weight: bold">::</span> width

sh%color <span style="color: #666666">=</span> color
sh%filled <span style="color: #666666">=</span> filled
sh%x <span style="color: #666666">=</span> x
sh%y <span style="color: #666666">=</span> y
<span style="color: #008000; font-weight: bold">select type</span> (sh)
<span style="color: #008000; font-weight: bold">type is</span> (<span style="color: #008000">shape</span>)
      <span style="color: #408080; font-style: italic">! no further initialization required</span>
<span style="color: #008000; font-weight: bold">class is</span> (rectangle)
    <span style="color: #408080; font-style: italic">! rectangle or square specific initializations</span>
    <span style="color: #008000; font-weight: bold">if</span> (<span style="color: #008000">present</span>(length))  <span style="color: #008000; font-weight: bold">then</span>
<span style="color: #008000; font-weight: bold">       </span>sh%length <span style="color: #666666">=</span> length
    <span style="color: #008000; font-weight: bold">else</span>
<span style="color: #008000; font-weight: bold">       </span>sh%length <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    endif
    <span style="color: #008000; font-weight: bold">if</span> (<span style="color: #008000">present</span>(width)) <span style="color: #008000; font-weight: bold">then</span>
<span style="color: #008000; font-weight: bold">        </span>sh%width <span style="color: #666666">=</span> width
    <span style="color: #008000; font-weight: bold">else</span>
<span style="color: #008000; font-weight: bold">        </span>sh%width <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    endif
<span style="color: #008000; font-weight: bold">class </span>default
  <span style="color: #408080; font-style: italic">! give error for unexpected/unsupported type</span>
     <span style="color: #008000; font-weight: bold">stop</span> <span style="color: #BA2121">&#39;initialize: unexpected type for sh object!&#39;</span>
<span style="color: #008000; font-weight: bold">end select</span>
<span style="color: #008000; font-weight: bold">end subroutine </span>initialize
</pre></div>
<p>
The above example illustrates an initialization procedure for our
shape example. It takes one shape argument, sh, and a set of initial
values for the components of sh. Two optional arguments, length and
width, are specified when we want to initialize a rectangle or a
square object. The SELECT TYPE construct allows us to perform a type
check on an object. There are two styles of type checks that we can
perform. The first type check is called "type is". This type test is
satisfied if the dynamic type of the object is the same as the type
specified in parentheses following the "type is" keyword. The second
type check is called "class is". This type test is satisfied if the
dynamic type of the object is the same or an extension of the
specified type in parentheses following the "class is" keyword.

<p>
Returning to our example, we will initialize the length and width
fields if the type of sh is rectangle or square. If the dynamic type
of sh is not a shape, rectangle, or square, then we will execute the
"class default" branch. This branch may get executed if we extended
the shape type without updating the initialize subroutine. Because we
added a "class default" branch, we also added the type is (shape)
branch, even though it does not perform any additional
assignments. Otherwise, we would incorrectly print our error message
when sh is of type shape.

<h2 id="___sec4">Procedure Polymorphism with Type-Bound Procedures </h2>

<p>
In the section on Objects in Fortran 90/95/2003 we mentioned that derived
types in F2003 are considered objects because they now can encapsulate
data as well as procedures. Procedures encapsulated in a derived type
are called type-bound procedures. Below illustrates how we may add a
type-bound procedure to shape:
<p>

<!-- code=fortran (!bc fcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">type </span><span style="color: #008000">shape</span>
<span style="color: #008000">        </span><span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> color
        <span style="color: #B00040">logical</span> <span style="color: #008000; font-weight: bold">::</span> filled
        <span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> x
        <span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> y
   <span style="color: #008000; font-weight: bold">contains</span>
<span style="color: #008000; font-weight: bold">        procedure</span> <span style="color: #008000; font-weight: bold">::</span> initialize
<span style="color: #008000; font-weight: bold">end type </span><span style="color: #008000">shape</span>
</pre></div>
<p>
F2003 added a contains keyword to its derived types to separate a
type's data definitions from its procedures. Anything that appears
after the contains keyword in a derived type must be a type-bound
procedure declaration. Below is the syntax of the type-bound procedure
declaration:
<p>

<!-- code=fortran (!bc fcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">PROCEDURE</span> [(<span style="color: #008000; font-weight: bold">interface</span><span style="color: #666666">-</span>name)] [[,binding<span style="color: #666666">-</span>attr<span style="color: #666666">-</span>list ]<span style="color: #008000; font-weight: bold">::</span>] binding<span style="color: #666666">-</span>name[<span style="color: #666666">=&gt;</span> <span style="color: #008000; font-weight: bold">procedure</span><span style="color: #666666">-</span>name]
</pre></div>
<p>
Anything in brackets is considered optional in the type-bound
procedure syntax above. At the minimum, a type-bound procedure is
declared with the PROCEDURE keyword followed with a binding-name. The
binding-name is the name of the type-bound procedure.

<p>
The first option is called interface-name.

<p>
The binding-attr-list option is a list of binding-attributes. The
binding-attributes that we will discuss in this article include PASS,
NOPASS, NON_OVERRIDABLE, PUBLIC, and PRIVATE. There is one other
binding-attribute, called DEFERRED.

<p>
The procedure-name option is the name of the underlying procedure that
implements the type-bound procedure. This option is required if the
name of the underlying procedure differs from the binding-name. The
procedure-name can be either a module procedure or an external
procedure with an explicit interface.

<p>
In our example above, we have a binding-name called
initialize. Because procedure-name was not specified, an implicit
procedure-name, called initialize is also declared. Another way to
write our example above is "procedure :: initialize => initialize".

<p>
Below is an example of a type-bound procedure that uses a module procedure:
<p>

<!-- code=fortran (!bc fcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">module </span>shape_mod
<span style="color: #008000; font-weight: bold">type </span><span style="color: #008000">shape</span>
<span style="color: #008000">        </span><span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> color
        <span style="color: #B00040">logical</span> <span style="color: #008000; font-weight: bold">::</span> filled
        <span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> x
        <span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> y
   <span style="color: #008000; font-weight: bold">contains</span>
<span style="color: #008000; font-weight: bold">        procedure</span> <span style="color: #008000; font-weight: bold">::</span> initialize
<span style="color: #008000; font-weight: bold">end type </span><span style="color: #008000">shape</span>
<span style="color: #008000; font-weight: bold">type</span>, <span style="color: #008000; font-weight: bold">extends</span>(<span style="color: #008000">shape</span>) <span style="color: #008000; font-weight: bold">::</span> rectangle
        <span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> length
        <span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> width
<span style="color: #008000; font-weight: bold">end type </span>rectangle
<span style="color: #008000; font-weight: bold">type</span>, <span style="color: #008000; font-weight: bold">extends</span>(rectangle) <span style="color: #008000; font-weight: bold">::</span> square
<span style="color: #008000; font-weight: bold">end type </span>square
<span style="color: #008000; font-weight: bold">contains</span>
<span style="color: #008000; font-weight: bold">subroutine </span>initialize(sh, color, filled, x, y, length, width)
<span style="color: #408080; font-style: italic">! initialize shape objects</span>
<span style="color: #008000; font-weight: bold">class</span>(<span style="color: #008000">shape</span>) <span style="color: #008000; font-weight: bold">::</span> sh
<span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> color
<span style="color: #B00040">logical</span> <span style="color: #008000; font-weight: bold">::</span> filled
<span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> x
<span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> y
<span style="color: #B00040">integer</span>, <span style="color: #008000; font-weight: bold">optional</span> <span style="color: #008000; font-weight: bold">::</span> length
<span style="color: #B00040">integer</span>, <span style="color: #008000; font-weight: bold">optional</span> <span style="color: #008000; font-weight: bold">::</span> width

sh%color <span style="color: #666666">=</span> color
sh%filled <span style="color: #666666">=</span> filled
sh%x <span style="color: #666666">=</span> x
sh%y <span style="color: #666666">=</span> y
<span style="color: #008000; font-weight: bold">select type</span> (sh)
<span style="color: #008000; font-weight: bold">type is</span> (<span style="color: #008000">shape</span>)
      <span style="color: #408080; font-style: italic">! no further initialization required</span>
<span style="color: #008000; font-weight: bold">class is</span> (rectangle)
    <span style="color: #408080; font-style: italic">! rectangle or square specific initializations</span>
    <span style="color: #008000; font-weight: bold">if</span> (<span style="color: #008000">present</span>(length))  <span style="color: #008000; font-weight: bold">then</span>
<span style="color: #008000; font-weight: bold">       </span>sh%length <span style="color: #666666">=</span> length
    <span style="color: #008000; font-weight: bold">else</span>
<span style="color: #008000; font-weight: bold">       </span>sh%length <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    endif
    <span style="color: #008000; font-weight: bold">if</span> (<span style="color: #008000">present</span>(width)) <span style="color: #008000; font-weight: bold">then</span>
<span style="color: #008000; font-weight: bold">        </span>sh%width <span style="color: #666666">=</span> width
    <span style="color: #008000; font-weight: bold">else</span>
<span style="color: #008000; font-weight: bold">        </span>sh%width <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    endif
<span style="color: #008000; font-weight: bold">class </span>default
  <span style="color: #408080; font-style: italic">! give error for unexpected/unsupported type</span>
     <span style="color: #008000; font-weight: bold">stop</span> <span style="color: #BA2121">&#39;initialize: unexpected type for sh object!&#39;</span>
<span style="color: #008000; font-weight: bold">end select</span>
<span style="color: #008000; font-weight: bold">end subroutine </span>initialize
<span style="color: #008000; font-weight: bold">end module</span>
</pre></div>
<p>
Below is an example of a type-bound procedure that uses an external procedure with an explicit interface:
<p>

<!-- code=fortran (!bc fcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">module </span>shape_mod
<span style="color: #008000; font-weight: bold">type </span><span style="color: #008000">shape</span>
<span style="color: #008000">        </span><span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> color
        <span style="color: #B00040">logical</span> <span style="color: #008000; font-weight: bold">::</span> filled
        <span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> x
        <span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> y
   <span style="color: #008000; font-weight: bold">contains</span>
<span style="color: #008000; font-weight: bold">        procedure</span> <span style="color: #008000; font-weight: bold">::</span> initialize
<span style="color: #008000; font-weight: bold">end type </span><span style="color: #008000">shape</span>
<span style="color: #008000; font-weight: bold">type</span>, <span style="color: #008000; font-weight: bold">extends</span>(<span style="color: #008000">shape</span>) <span style="color: #008000; font-weight: bold">::</span> rectangle
        <span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> length
        <span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> width
<span style="color: #008000; font-weight: bold">end type </span>rectangle
<span style="color: #008000; font-weight: bold">type</span>, <span style="color: #008000; font-weight: bold">extends</span>(rectangle) <span style="color: #008000; font-weight: bold">::</span> square
<span style="color: #008000; font-weight: bold">end type </span>square
<span style="color: #008000; font-weight: bold">interface</span>
<span style="color: #008000; font-weight: bold">    subroutine </span>initialize(sh, color, filled, x, y, length, width)
    <span style="color: #008000; font-weight: bold">import </span><span style="color: #008000">shape</span>
<span style="color: #008000">    </span><span style="color: #008000; font-weight: bold">class</span>(<span style="color: #008000">shape</span>) <span style="color: #008000; font-weight: bold">::</span> sh
    <span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> color
    <span style="color: #B00040">logical</span> <span style="color: #008000; font-weight: bold">::</span> filled
    <span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> x
    <span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> y
    <span style="color: #B00040">integer</span>, <span style="color: #008000; font-weight: bold">optional</span> <span style="color: #008000; font-weight: bold">::</span> length
    <span style="color: #B00040">integer</span>, <span style="color: #008000; font-weight: bold">optional</span> <span style="color: #008000; font-weight: bold">::</span> width
  <span style="color: #008000; font-weight: bold">end subroutine</span>
<span style="color: #008000; font-weight: bold">end interface</span>
<span style="color: #008000; font-weight: bold">end module</span>
</pre></div>
<p>
Using the examples above, we can invoke the type-bound procedure in the following manner:

<p>

<!-- code=fortran (!bc fcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">use </span>shape_mod
<span style="color: #008000; font-weight: bold">type</span>(<span style="color: #008000">shape</span>) <span style="color: #008000; font-weight: bold">::</span> shp                       <span style="color: #408080; font-style: italic">! declare an instance of shape</span>
<span style="color: #008000; font-weight: bold">call </span>shp%initialize(<span style="color: #666666">1</span>, .true., <span style="color: #666666">10</span>, <span style="color: #666666">20</span>)   <span style="color: #408080; font-style: italic">! initialize shape</span>
</pre></div>
<p>
The syntax for invoking a type-bound procedure is very similar to
accessing a data component in a derived type. The name of the
component is preceded by the variable name separated by a percent (%)
sign. In this case, the name of the component is initialize and the
name of the variable is shp. So, we type shp%initialize to access the
initialize type-bound procedure. The above example calls the
initialize subroutine and passes in 1 for color, .true. for filled, 10
for x, and 20 for y.

<p>
You may notice that we have not yet mentioned anything about the first
dummy argument, sh, in initialize. This dummy argument is known as the
passed-object dummy argument. By default, the passed-object dummy is
the first dummy argument in the type-bound procedure. It receives the
object that invoked the type-bound procedure. In our example, sh is
the passed-object dummy and the invoking object is shp. Therefore, the
shp object gets assigned to sh when initialize is invoked.

<p>
The passed-object dummy argument must be declared CLASS and of the
same type as the derived type that defined the type-bound
procedure. For example, a type bound procedure declared in shape must
have a passed-object dummy argument declared "class(shape)".

<p>
We can also specify a different passed-object dummy argument using the
PASS binding-attribute. For example, let's say that the sh dummy in
our initialize subroutine did not appear as the first argument. Then
we would need to specify a PASS attribute like in the following code:

<p>

<!-- code=fortran (!bc fcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">type </span><span style="color: #008000">shape</span>
<span style="color: #008000">        </span><span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> color
        <span style="color: #B00040">logical</span> <span style="color: #008000; font-weight: bold">::</span> filled
        <span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> x
        <span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> y
   <span style="color: #008000; font-weight: bold">contains</span>
<span style="color: #008000; font-weight: bold">        procedure</span>, <span style="color: #008000; font-weight: bold">pass</span>(sh) <span style="color: #008000; font-weight: bold">::</span> initialize
<span style="color: #008000; font-weight: bold">end type </span><span style="color: #008000">shape</span>
</pre></div>
<p>
Sometimes we do not want to specify a passed-object dummy argument. We can choose to not specify one using the NOPASS binding-attribute:

<p>

<!-- code=fortran (!bc fcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">type </span><span style="color: #008000">shape</span>
<span style="color: #008000">        </span><span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> color
        <span style="color: #B00040">logical</span> <span style="color: #008000; font-weight: bold">::</span> filled
        <span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> x
        <span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> y
   <span style="color: #008000; font-weight: bold">contains</span>
<span style="color: #008000; font-weight: bold">        procedure</span>, <span style="color: #008000; font-weight: bold">nopass</span> <span style="color: #008000; font-weight: bold">::</span> initialize
<span style="color: #008000; font-weight: bold">end type </span><span style="color: #008000">shape</span>
</pre></div>
<p>
If we specify NOPASS in our example, then we still invoke the
type-bound procedure the same way. The only difference is that the
invoking object is not automatically assigned to a passed-object dummy
in the type-bound procedure. Therefore, if we were to specify NOPASS
in our initialize type-bound procedure, we would invoke initialize in
the following manner:

<p>

<!-- code=fortran (!bc fcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">type</span>(<span style="color: #008000">shape</span>) <span style="color: #008000; font-weight: bold">::</span> shp                            <span style="color: #408080; font-style: italic">! declare an instance of shape</span>
<span style="color: #008000; font-weight: bold">call </span>shp%initialize(shp, <span style="color: #666666">1</span>, .true., <span style="color: #666666">10</span>, <span style="color: #666666">20</span>)   <span style="color: #408080; font-style: italic">! initialize shape</span>
</pre></div>
<p>
Note that we explicitly specify shp for the first argument of initialize because it was declared NOPASS.

<h2 id="___sec5">Inheritance and Type-Bound Procedures </h2>

<p>
Recall from the part on Objects in Fortran 90/95/2003, that a child
type inherits or reuses components from their parent or ancestor
types. This applies to both data and procedures when dealing with
F2003 derived types. In the code below, rectangle and square will both
inherit the initialize type-bound procedure from shape.

<p>

<!-- code=fortran (!bc fcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">type </span><span style="color: #008000">shape</span>
<span style="color: #008000">        </span><span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> color
        <span style="color: #B00040">logical</span> <span style="color: #008000; font-weight: bold">::</span> filled
        <span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> x
        <span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> y
   <span style="color: #008000; font-weight: bold">contains</span>
<span style="color: #008000; font-weight: bold">        procedure</span> <span style="color: #008000; font-weight: bold">::</span> initialize
<span style="color: #008000; font-weight: bold">end type </span><span style="color: #008000">shape</span>
<span style="color: #008000; font-weight: bold">type</span>, <span style="color: #008000; font-weight: bold">EXTENDS</span> ( <span style="color: #008000">shape</span> ) <span style="color: #008000; font-weight: bold">::</span> rectangle
        <span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> length
        <span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> width
<span style="color: #008000; font-weight: bold">end type </span>rectangle
<span style="color: #008000; font-weight: bold">type</span>, <span style="color: #008000; font-weight: bold">EXTENDS</span> ( rectangle ) <span style="color: #008000; font-weight: bold">::</span> square
<span style="color: #008000; font-weight: bold">end type </span>square

Using the example above, we can invoke initialize with a <span style="color: #008000">shape</span>, rectangle, <span style="color: #008000">or </span>square object:

<span style="color: #008000; font-weight: bold">type</span>(<span style="color: #008000">shape</span>) <span style="color: #008000; font-weight: bold">::</span> shp                                  <span style="color: #408080; font-style: italic">! declare an instance of shape</span>
<span style="color: #008000; font-weight: bold">type</span>(rectangle) <span style="color: #008000; font-weight: bold">::</span> rect                             <span style="color: #408080; font-style: italic">! declare an instance of rectangle</span>
<span style="color: #008000; font-weight: bold">type</span>(square) <span style="color: #008000; font-weight: bold">::</span> sq                                  <span style="color: #408080; font-style: italic">! declare an instance of square</span>
<span style="color: #008000; font-weight: bold">call </span>shp%initialize(<span style="color: #666666">1</span>, .true., <span style="color: #666666">10</span>, <span style="color: #666666">20</span>)              <span style="color: #408080; font-style: italic">! initialize shape</span>
<span style="color: #008000; font-weight: bold">call </span>rect%initialize(<span style="color: #666666">2</span>, .false., <span style="color: #666666">100</span>, <span style="color: #666666">200</span>, <span style="color: #666666">50</span>, <span style="color: #666666">25</span>)  <span style="color: #408080; font-style: italic">! initialize rectangle</span>
<span style="color: #008000; font-weight: bold">call </span>sq%initialize(<span style="color: #666666">3</span>, .false., <span style="color: #666666">400</span>, <span style="color: #666666">500</span>, <span style="color: #666666">30</span>, <span style="color: #666666">20</span>)    <span style="color: #408080; font-style: italic">! initialize rectangle</span>
</pre></div>

<h2 id="___sec6">Procedure Overriding </h2>

<p>
Most OOP languages allow a child object to override a procedure
inherited from its parent object. This is known as procedure
overriding. In F2003, we can specify a type-bound procedure in a child
type that has the same binding-name as a type-bound procedure in the
parent type. When the child overrides a particular type-bound
procedure, the version defined in its derived type will get invoked
instead of the version defined in the parent. Below is an example
where rectangle defines an initialize type-bound procedure that
overrides shape's initialize type-bound procedure:

<p>

<!-- code=fortran (!bc fcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">module </span>shape_mod
<span style="color: #008000; font-weight: bold">type </span><span style="color: #008000">shape</span>
<span style="color: #008000">        </span><span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> color
        <span style="color: #B00040">logical</span> <span style="color: #008000; font-weight: bold">::</span> filled
        <span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> x
        <span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> y
   <span style="color: #008000; font-weight: bold">contains</span>
<span style="color: #008000; font-weight: bold">        procedure</span> <span style="color: #008000; font-weight: bold">::</span> initialize <span style="color: #666666">=&gt;</span> initShape
<span style="color: #008000; font-weight: bold">end type </span><span style="color: #008000">shape</span>
<span style="color: #008000; font-weight: bold">type</span>, <span style="color: #008000; font-weight: bold">EXTENDS</span> ( <span style="color: #008000">shape</span> ) <span style="color: #008000; font-weight: bold">::</span> rectangle
        <span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> length
        <span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> width
   <span style="color: #008000; font-weight: bold">contains</span>
<span style="color: #008000; font-weight: bold">        procedure</span> <span style="color: #008000; font-weight: bold">::</span> initialize <span style="color: #666666">=&gt;</span> initRectangle
<span style="color: #008000; font-weight: bold">end type </span>rectangle
<span style="color: #008000; font-weight: bold">type</span>, <span style="color: #008000; font-weight: bold">EXTENDS</span> ( rectangle ) <span style="color: #008000; font-weight: bold">::</span> square
<span style="color: #008000; font-weight: bold">end type </span>square
<span style="color: #008000; font-weight: bold">contains</span>
<span style="color: #008000; font-weight: bold">subroutine </span>initShape(this, color, filled, x, y, length, width)
<span style="color: #408080; font-style: italic">! initialize shape objects</span>
<span style="color: #008000; font-weight: bold">class</span>(<span style="color: #008000">shape</span>) <span style="color: #008000; font-weight: bold">::</span> this
<span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> color
<span style="color: #B00040">logical</span> <span style="color: #008000; font-weight: bold">::</span> filled
<span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> x
<span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> y
<span style="color: #B00040">integer</span>, <span style="color: #008000; font-weight: bold">optional</span> <span style="color: #008000; font-weight: bold">::</span> length  <span style="color: #408080; font-style: italic">! ingnored for shape</span>
<span style="color: #B00040">integer</span>, <span style="color: #008000; font-weight: bold">optional</span> <span style="color: #008000; font-weight: bold">::</span> width   <span style="color: #408080; font-style: italic">! ignored for shape</span>

this%color <span style="color: #666666">=</span> color
this%filled <span style="color: #666666">=</span> filled
this%x <span style="color: #666666">=</span> x
this%y <span style="color: #666666">=</span> y
<span style="color: #008000; font-weight: bold">end subroutine</span>
<span style="color: #008000; font-weight: bold">subroutine </span>initRectangle(this, color, filled, x, y, length, width)
<span style="color: #408080; font-style: italic">! initialize rectangle objects</span>
<span style="color: #008000; font-weight: bold">class</span>(rectangle) <span style="color: #008000; font-weight: bold">::</span> this
<span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> color
<span style="color: #B00040">logical</span> <span style="color: #008000; font-weight: bold">::</span> filled
<span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> x
<span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> y
<span style="color: #B00040">integer</span>, <span style="color: #008000; font-weight: bold">optional</span> <span style="color: #008000; font-weight: bold">::</span> length  
<span style="color: #B00040">integer</span>, <span style="color: #008000; font-weight: bold">optional</span> <span style="color: #008000; font-weight: bold">::</span> width   

this%color <span style="color: #666666">=</span> color
this%filled <span style="color: #666666">=</span> filled
this%x <span style="color: #666666">=</span> x
this%y <span style="color: #666666">=</span> y
<span style="color: #008000; font-weight: bold">if</span> (<span style="color: #008000">present</span>(length)) <span style="color: #008000; font-weight: bold">then</span>
<span style="color: #008000; font-weight: bold">   </span>this%length <span style="color: #666666">=</span> length
<span style="color: #008000; font-weight: bold">else</span>
<span style="color: #008000; font-weight: bold">   </span>this%length <span style="color: #666666">=</span> <span style="color: #666666">0</span>
endif
<span style="color: #008000; font-weight: bold">if</span> (<span style="color: #008000">present</span>(width)) <span style="color: #008000; font-weight: bold">then </span>
<span style="color: #008000; font-weight: bold">    </span>this%width <span style="color: #666666">=</span> width
<span style="color: #008000; font-weight: bold">else</span>
<span style="color: #008000; font-weight: bold">     </span>this%width <span style="color: #666666">=</span> <span style="color: #666666">0</span>
endif
<span style="color: #008000; font-weight: bold">end subroutine</span>
<span style="color: #008000; font-weight: bold">end module</span>
</pre></div>
<p>
In the sample code above, we defined a type-bound procedure called
initialize for both shape and rectangle. The only difference is that
shape's version of initialize will invoke a procedure called initShape
and rectangle's version will invoke a procedure called
initRectangle. Note that the passed-object dummy in initShape is
declared "class(shape)" and the passed-object dummy in initRectangle
is declared "class(rectangle)". Recall that a type-bound procedure's
passed-object dummy must match the type of the derived type that
defined it. Other than differing passed-object dummy arguments, the
interface for the child's overriding type-bound procedure is identical
with the interface for the parent's type-bound procedure. That is
because both type-bound procedures are invoked in the same manner:

<p>

<!-- code=fortran (!bc fcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">type</span>(<span style="color: #008000">shape</span>) <span style="color: #008000; font-weight: bold">::</span> shp                                  <span style="color: #408080; font-style: italic">! declare an instance of shape</span>
<span style="color: #008000; font-weight: bold">type</span>(rectangle) <span style="color: #008000; font-weight: bold">::</span> rect                             <span style="color: #408080; font-style: italic">! declare an instance of rectangle</span>
<span style="color: #008000; font-weight: bold">type</span>(square) <span style="color: #008000; font-weight: bold">::</span> sq                                  <span style="color: #408080; font-style: italic">! declare an instance of square</span>
<span style="color: #008000; font-weight: bold">call </span>shp%initialize(<span style="color: #666666">1</span>, .true., <span style="color: #666666">10</span>, <span style="color: #666666">20</span>)              <span style="color: #408080; font-style: italic">! calls initShape</span>
<span style="color: #008000; font-weight: bold">call </span>rect%initialize(<span style="color: #666666">2</span>, .false., <span style="color: #666666">100</span>, <span style="color: #666666">200</span>, <span style="color: #666666">11</span>, <span style="color: #666666">22</span>)  <span style="color: #408080; font-style: italic">! calls initRectangle </span>
<span style="color: #008000; font-weight: bold">call </span>sq%initialize(<span style="color: #666666">3</span>, .false., <span style="color: #666666">400</span>, <span style="color: #666666">500</span>)            <span style="color: #408080; font-style: italic">! calls initRectangle</span>
</pre></div>
<p>
Note that sq is declared square but its initialize type-bound
procedure invokes initRectangle because sq inherits the rectangle
version of initialize.

<p>
Although a type may override a type-bound procedure, it is still
possible to invoke the version defined by a parent type. Recall in
section 2, "Objects in Fortran 90/95/2003", that each type extension
contains an implicit parent object of the same name and type as the
parent. We can use this implicit parent object to access components
specific to a parent, say, a parent's version of a type-bound
procedure:

<p>

<!-- code=fortran (!bc fcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">call </span>rect%<span style="color: #008000">shape</span>%initialize(<span style="color: #666666">2</span>, .false., <span style="color: #666666">100</span>, <span style="color: #666666">200</span>)         <span style="color: #408080; font-style: italic">! calls initShape</span>
<span style="color: #008000; font-weight: bold">call </span>sq%rectangle%<span style="color: #008000">shape</span>%initialize(<span style="color: #666666">3</span>, .false., <span style="color: #666666">400</span>, <span style="color: #666666">500</span>) <span style="color: #408080; font-style: italic">! calls initShape</span>
</pre></div>
<p>
Sometimes we may not want a child to override a parent's type-bound
procedure. We can use the NON_OVERRIDABLE binding-attribute to prevent
any type extensions from overriding a particular type-bound procedure:

<p>

<!-- code=fortran (!bc fcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">type </span><span style="color: #008000">shape</span>
<span style="color: #008000">        </span><span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> color
        <span style="color: #B00040">logical</span> <span style="color: #008000; font-weight: bold">::</span> filled
        <span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> x
        <span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> y
   <span style="color: #008000; font-weight: bold">contains</span>
<span style="color: #008000; font-weight: bold">        procedure</span>, <span style="color: #008000; font-weight: bold">non_overridable</span> <span style="color: #008000; font-weight: bold">::</span> initialize
<span style="color: #008000; font-weight: bold">end type </span><span style="color: #008000">shape</span>
</pre></div>

<h2 id="___sec7">Functions as Type-Bound Procedures </h2>

<p>
Up to this point, subroutines have been used to implement type-bound
procedures. We can also implement type-bound procedures with functions
as well. Below is an example with a function that queries the status
of the filled component in shape.

<p>

<!-- code=fortran (!bc fcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">module </span>shape_mod
<span style="color: #008000; font-weight: bold">type </span><span style="color: #008000">shape</span>
<span style="color: #008000">        </span><span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> color
        <span style="color: #B00040">logical</span> <span style="color: #008000; font-weight: bold">::</span> filled
        <span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> x
        <span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> y
   <span style="color: #008000; font-weight: bold">contains</span>
<span style="color: #008000; font-weight: bold">        procedure</span> <span style="color: #008000; font-weight: bold">::</span> isFilled
<span style="color: #008000; font-weight: bold">end type </span><span style="color: #008000">shape</span>
<span style="color: #008000; font-weight: bold">contains</span>
<span style="color: #008000; font-weight: bold">     </span><span style="color: #B00040">logical </span><span style="color: #008000; font-weight: bold">function </span>isFilled(this)
     <span style="color: #008000; font-weight: bold">class</span>(<span style="color: #008000">shape</span>) <span style="color: #008000; font-weight: bold">::</span> this
     isFilled <span style="color: #666666">=</span> this%filled
     <span style="color: #008000; font-weight: bold">end function</span>
<span style="color: #008000; font-weight: bold">end module</span>
</pre></div>
<p>
We can invoke the above function in the following manner:

<p>

<!-- code=fortran (!bc fcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">use </span>shape_mod
<span style="color: #008000; font-weight: bold">type</span>(<span style="color: #008000">shape</span>) <span style="color: #008000; font-weight: bold">::</span> shp        <span style="color: #408080; font-style: italic">! declare an instance of shape</span>
<span style="color: #B00040">logical </span>filled
<span style="color: #008000; font-weight: bold">call </span>shp%initialize(<span style="color: #666666">1</span>, .true., <span style="color: #666666">10</span>, <span style="color: #666666">20</span>)              
filled <span style="color: #666666">=</span> shp%isFilled()
</pre></div>

<h2 id="___sec8">Information Hiding </h2>

<p>
In the section on Procedure Overriding, we showed how a child type can
override a parent's type-bound procedure. This allows a user of our
type to invoke, say, the initialize type-bound procedure, without any
knowledge of the implementation details of initialize. This is an
example of information hiding, another important feature of OOP.

<p>
Information hiding allows the programmer to view an object and its
procedures as a "black box". That is, the programmer can use (or
reuse) an object without any knowledge of the implementation details
of the object.

<p>
Inquiry functions, like the isFilled function in section 8, "Functions
as Type-Bound Procedures", are common with information hiding. The
motivation for inquiry functions, rather than direct access to the
underlying data, is that the object's implementer can change the
underlying data without affecting the programs that use the
object. Otherwise, each program that uses the object would need to be
updated whenever the underlying data of the object changes.

<p>
To enable information hiding, F2003 provides a PRIVATE keyword (and
binding-attribute). F2003 also provides a PUBLIC keyword (and
binding-attribute) to disable information hiding. By default, all
derived type components are declared PUBLIC. The PRIVATE keyword can
be placed on derived type data and type-bound procedure components
(and on module data and procedures). We illustrate PUBLIC and PRIVATE
in the sample code below:

<p>

<!-- code=fortran (!bc fcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">module </span>shape_mod
<span style="color: #008000; font-weight: bold">private</span>    <span style="color: #408080; font-style: italic">! hide the type-bound procedure implementation procedures</span>
<span style="color: #008000; font-weight: bold">public</span> <span style="color: #008000; font-weight: bold">::</span> <span style="color: #008000">shape</span>, constructor   <span style="color: #408080; font-style: italic">! allow access to shape &amp; constructor procedure</span>
<span style="color: #008000; font-weight: bold">type </span><span style="color: #008000">shape</span>
<span style="color: #008000">   </span><span style="color: #008000; font-weight: bold">private</span>               <span style="color: #408080; font-style: italic">! hide the underlying details</span>
        <span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> color
        <span style="color: #B00040">logical</span> <span style="color: #008000; font-weight: bold">::</span> filled
        <span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> x
        <span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> y
   <span style="color: #008000; font-weight: bold">contains</span>
<span style="color: #008000; font-weight: bold">   private</span>                 <span style="color: #408080; font-style: italic">! hide the type bound procedures by default</span>
   <span style="color: #008000; font-weight: bold">procedure</span> <span style="color: #008000; font-weight: bold">::</span> initShape  <span style="color: #408080; font-style: italic">! private type-bound procedure</span>
        <span style="color: #008000; font-weight: bold">procedure</span>, <span style="color: #008000; font-weight: bold">public</span> <span style="color: #008000; font-weight: bold">::</span> isFilled <span style="color: #408080; font-style: italic">! allow access to isFilled type-bound procedure</span>
        <span style="color: #008000; font-weight: bold">procedure</span>, <span style="color: #008000; font-weight: bold">public</span> <span style="color: #008000; font-weight: bold">::</span> <span style="color: #008000; font-weight: bold">print</span> <span style="color: #408080; font-style: italic">! allow access to print type-bound procedure</span>
<span style="color: #008000; font-weight: bold">end type </span><span style="color: #008000">shape</span>
<span style="color: #008000; font-weight: bold">contains</span>

<span style="color: #B00040">logical </span><span style="color: #008000; font-weight: bold">function </span>isFilled(this)
<span style="color: #008000; font-weight: bold">class</span>(<span style="color: #008000">shape</span>) <span style="color: #008000; font-weight: bold">::</span> this

isFilled <span style="color: #666666">=</span> this%filled

<span style="color: #008000; font-weight: bold">end function</span>
<span style="color: #008000; font-weight: bold"> </span>
<span style="color: #008000; font-weight: bold">function </span>constructor(color, filled, x, y)
<span style="color: #008000; font-weight: bold">type</span>(<span style="color: #008000">shape</span>) <span style="color: #008000; font-weight: bold">::</span> constructor
<span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> color
<span style="color: #B00040">logical</span> <span style="color: #008000; font-weight: bold">::</span> filled
<span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> x
<span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> y
 <span style="color: #008000; font-weight: bold">call </span>constructor%initShape(color, filled, x, y)
<span style="color: #008000; font-weight: bold">end function</span>
<span style="color: #008000; font-weight: bold">subroutine </span>initShape(this, color, filled, x, y)
<span style="color: #408080; font-style: italic">! initialize shape objects</span>
<span style="color: #008000; font-weight: bold">class</span>(<span style="color: #008000">shape</span>) <span style="color: #008000; font-weight: bold">::</span> this
<span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> color
<span style="color: #B00040">logical</span> <span style="color: #008000; font-weight: bold">::</span> filled
<span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> x
<span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> y

this%color <span style="color: #666666">=</span> color
this%filled <span style="color: #666666">=</span> filled
this%x <span style="color: #666666">=</span> x
this%y <span style="color: #666666">=</span> y
<span style="color: #008000; font-weight: bold">end subroutine</span>

<span style="color: #008000; font-weight: bold">subroutine print</span>(this)
<span style="color: #008000; font-weight: bold">class</span>(<span style="color: #008000">shape</span>) <span style="color: #008000; font-weight: bold">::</span> this
<span style="color: #008000; font-weight: bold">print</span> <span style="color: #666666">*</span>, this%color, this%filled, this%x, this%y
  
<span style="color: #008000; font-weight: bold">end subroutine</span>
<span style="color: #008000; font-weight: bold">end module</span>
</pre></div>
<p>
The example above uses information hiding in the host module as well
as in the shape type. The private statement, located at the top of the
module, enables information hiding on all module data and
procedures. The isFilled module procedure (not to be confused with the
isFilled type-bound procedure) is hidden as a result of the private
statement at the top of the module. We added public :: constructor to
allow the user to invoke the constructor module procedure. We added a
private statement on the data components of shape. Now, the only way a
user can query the filled component is through the isFilled type-bound
procedure, which is declared public.

<p>
Note the private statement after the contains in type shape. The
private that appears after type shape only affects the data components
of shape. If you want your type-bound procedures to also be private,
then a private statement must also be added after the contains
keyword. Otherwise, type-bound procedures are public by default.

<p>
In our example, the initShape type-bound procedure is declared
private. Therefore, only procedures local to the host module can
invoke a private type-bound procedure. In our example above, the
constructor module procedure invokes the initShape type-bound
procedure. Below is how we may invoke our example from above:

<p>

<!-- code=fortran (!bc fcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">program </span>shape_prg
<span style="color: #008000; font-weight: bold">use </span>shape_mod
<span style="color: #008000; font-weight: bold">type</span>(<span style="color: #008000">shape</span>) <span style="color: #008000; font-weight: bold">::</span> sh
<span style="color: #B00040">logical </span>filled
sh <span style="color: #666666">=</span> constructor(<span style="color: #666666">5</span>, .true., <span style="color: #666666">100</span>, <span style="color: #666666">200</span>)
<span style="color: #008000; font-weight: bold">call </span>sh%<span style="color: #008000; font-weight: bold">print</span>()
<span style="color: #008000; font-weight: bold">end</span>
</pre></div>
<p>
Below is a sample compile and sample run of the above program (we
assume that the shape_mod module is saved in a file called shape.f03
and that the main program is called main.f03):
<p>

<!-- code=fortran (!bc fcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>% pgfortran <span style="color: #666666">-</span>V ; pgfortran <span style="color: #008000">shape</span>.f03 main.f03 <span style="color: #666666">-</span>o shapeTest
pgfortran <span style="color: #666666">11.2-1</span> <span style="color: #666666">64-</span>bit <span style="color: #008000; font-weight: bold">target </span>on x86<span style="color: #666666">-64</span> Linux <span style="color: #666666">-</span>tp penryn 
Copyright <span style="color: #666666">1989-2000</span>, The Portland Group, Inc.  <span style="color: #008000; font-weight: bold">All </span>Rights Reserved.
Copyright <span style="color: #666666">2000-2011</span>, STMicroelectronics, Inc.  <span style="color: #008000; font-weight: bold">All </span>Rights Reserved.
<span style="color: #008000">shape</span>.f03:
main.f03:
% shapeTest
            <span style="color: #666666">5</span>  T          <span style="color: #666666">100</span>          <span style="color: #666666">200</span>
</pre></div>

<h2 id="___sec9">Type Overloading </h2>

<p>
In our previous example, we created an instance of shape by invoking a
function called constructor. This allows us to hide the details for
constructing a shape object, including the underlying type-bound
procedure that performs the initialization. However, you may have
noticed that the word constructor could very well be defined somewhere
else in the host program. If that is the case, the program cannot use
our module without renaming one of the constructor functions. But
since OOP encourages information hiding and code reusability, it would
make more sense to come up with a name that probably is not being
defined in the host program. That name is the type name of the object
we are constructing.

<p>
F2003 allows the programmer to overload a name of a derived type with
a generic interface. The generic interface acts as a wrapper for our
constructor function. The idea is that the user would then construct a
shape in the following manner:

<p>

<!-- code=fortran (!bc fcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #008000; font-weight: bold">program </span>shape_prg
<span style="color: #008000; font-weight: bold">use </span>shape_mod
<span style="color: #008000; font-weight: bold">type</span>(<span style="color: #008000">shape</span>) <span style="color: #008000; font-weight: bold">::</span> sh
<span style="color: #B00040">logical </span>filled
sh <span style="color: #666666">=</span> <span style="color: #008000">shape</span>(<span style="color: #666666">5</span>, .true., <span style="color: #666666">100</span>, <span style="color: #666666">200</span>)  <span style="color: #408080; font-style: italic">! invoke constructor through shape generic interface</span>
<span style="color: #008000; font-weight: bold">call </span>sh%<span style="color: #008000; font-weight: bold">print</span>()
<span style="color: #008000; font-weight: bold">end</span>

Below <span style="color: #008000; font-weight: bold">is </span>the modified version of our example from section <span style="color: #666666">9</span>, <span style="color: #BA2121">&quot;Information Hiding&quot;</span>, that uses <span style="color: #008000; font-weight: bold">type </span>overloading:

<span style="color: #008000; font-weight: bold">module </span>shape_mod
<span style="color: #008000; font-weight: bold">private</span>    <span style="color: #408080; font-style: italic">! hide the type-bound procedure implementation procedures</span>
<span style="color: #008000; font-weight: bold">public</span> <span style="color: #008000; font-weight: bold">::</span> <span style="color: #008000">shape</span> <span style="color: #408080; font-style: italic">! allow access to shape</span>
<span style="color: #008000; font-weight: bold">type </span><span style="color: #008000">shape</span>
<span style="color: #008000">   </span><span style="color: #008000; font-weight: bold">private</span>               <span style="color: #408080; font-style: italic">! hide the underlying details</span>
        <span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> color
        <span style="color: #B00040">logical</span> <span style="color: #008000; font-weight: bold">::</span> filled
        <span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> x
        <span style="color: #B00040">integer</span> <span style="color: #008000; font-weight: bold">::</span> y
   <span style="color: #008000; font-weight: bold">contains</span>
<span style="color: #008000; font-weight: bold">   private</span>                 <span style="color: #408080; font-style: italic">! hide the type bound procedures by default</span>
   <span style="color: #008000; font-weight: bold">procedure</span> <span style="color: #008000; font-weight: bold">::</span> initShape  <span style="color: #408080; font-style: italic">! private type-bound procedure</span>
        <span style="color: #008000; font-weight: bold">procedure</span>, <span style="color: #008000; font-weight: bold">public</span> <span style="color: #008000; font-weight: bold">::</span> isFilled <span style="color: #408080; font-style: italic">! allow access to isFilled type-bound procedure</span>
<span style="color: #008000; font-weight: bold">end type </span><span style="color: #008000">shape</span>
<span style="color: #008000; font-weight: bold">interface </span><span style="color: #008000">shape</span>
<span style="color: #008000; font-weight: bold">procedure </span>constructor       <span style="color: #408080; font-style: italic">! add constructor to shape generic interface</span>
<span style="color: #008000; font-weight: bold">end interface</span>
<span style="color: #008000; font-weight: bold">contains</span>
     :
     :
<span style="color: #008000; font-weight: bold">end module</span>
</pre></div>
<p>
Our constructor function is now declared private and it is invoked through the shape public generic interface.

<h2 id="___sec10">Conclusion </h2>

<p>
Code reusability, an important feature of Object-Oriented Programming
(OOP), is enabled through inheritance, polymorphism, and information
hiding. With inheritance, an object can be extended and code from the
parent object can be reused or overloaded in the child object. Code
reusability is also enabled through polymorphism. There are two types
of polymorphism: procedure polymorphism and data
polymorphism. Procedure polymorphism enables code reusability because
a procedure can operate on a variety of data types and values. The
programmer does not have to reinvent the wheel for every data type a
program may encounter with a polymorphic procedure. Part 2 of this
article will cover data polymorphism. Finally, we examined information
hiding which allows programmers to use an object without having to
understand its underlying implementation details. Fortran 2003 (F2003)
supports inheritance, polymorphism, and information hiding through
type extension, the CLASS keyword, and the PUBLIC/PRIVATE
keywords/binding-attributes respectively.

<p>
We will continue our discussion of OOP with F2003 by examining the
other form of polymorphism, data polymorphism, and see how it can be
used to create flexible and reusable software components. We will also
examine the following OOP features offered by F2003: unlimited
polymorphic objects, typed allocation, sourced allocation, generic
type-bound procedures, deferred bindings, and abstract types.

<p>

<!-- ------------------- end of main content --------------- -->


<center style="font-size:80%">
<!-- copyright --> &copy; 1999-2017, Morten Hjorth-Jensen  Email morten.hjorth-jensen@fys.uio.no. Released under CC Attribution-NonCommercial 4.0 license
</center>


</body>
</html>
    

