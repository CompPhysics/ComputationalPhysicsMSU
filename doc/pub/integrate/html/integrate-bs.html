<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Computational Physics Lectures: Numerical integration, from Newton-Cotes quadrature to Gaussian quadrature">

<title>Computational Physics Lectures: Numerical integration, from Newton-Cotes quadrature to Gaussian quadrature</title>

<!-- Bootstrap style: bootstrap -->
<link href="https://netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap.min.css" rel="stylesheet">
<!-- not necessary
<link href="https://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
-->

<style type="text/css">

/* Add scrollbar to dropdown menus in bootstrap navigation bar */
.dropdown-menu {
   height: auto;
   max-height: 400px;
   overflow-x: hidden;
}

/* Adds an invisible element before each target to offset for the navigation
   bar */
.anchor::before {
  content:"";
  display:block;
  height:50px;      /* fixed header height for style bootstrap */
  margin:-50px 0 0; /* negative fixed header height */
}
</style>


<script src="https://sagecell.sagemath.org/static/jquery.min.js"></script>
<script src="https://sagecell.sagemath.org/embedded_sagecell.js"></script>
<link rel="stylesheet" type="text/css" href="https://sagecell.sagemath.org/static/sagecell_embed.css">
<script>
$(function () {
    // Make the div with id 'mycell' a Sage cell
    sagecell.makeSagecell({inputLocation:  '#mycell',
                           template:       sagecell.templates.minimal,
                           evalButtonText: 'Activate'});
    // Make *any* div with class 'compute' a Sage cell
    sagecell.makeSagecell({inputLocation: 'div.compute',
                           evalButtonText: 'Evaluate'});
});
</script>

</head>

<!-- tocinfo
{'highest level': 2,
 'sections': [('Numerical Integration', 2, None, '___sec0'),
              ('Newton-Cotes Quadrature or equal-step methods',
               2,
               None,
               '___sec1'),
              ('Basic philosophy of equal-step methods', 2, None, '___sec2'),
              ('Simple algorithm for equal step methods', 2, None, '___sec3'),
              ('Simple algorithm for equal step methods', 2, None, '___sec4'),
              ("Lagrange's interpolation formula", 2, None, '___sec5'),
              ('Polynomial approximation', 2, None, '___sec6'),
              ('Simplifying the integral', 2, None, '___sec7'),
              ('The trapezoidal rule', 2, None, '___sec8'),
              ('Global error', 2, None, '___sec9'),
              ('Error in the trapezoidal rule', 2, None, '___sec10'),
              ('Algorithm for the trapezoidal rule', 2, None, '___sec11'),
              ('Code example', 2, None, '___sec12'),
              ('Transfer of  function names', 2, None, '___sec13'),
              ('Going back to Python, why?', 2, None, '___sec14'),
              ('Error analysis', 2, None, '___sec15'),
              ('Integrating numerical mathematics with calculus',
               2,
               None,
               '___sec16'),
              ('The rectangle method', 2, None, '___sec17'),
              ('Truncation error for the rectangular rule',
               2,
               None,
               '___sec18'),
              ('Second-order polynomial', 2, None, '___sec19'),
              ("Simpson's rule", 2, None, '___sec20'),
              ('Mathematical expressions for the truncation error',
               2,
               None,
               '___sec21'),
              ("Algorithm for Simpson's rule", 2, None, '___sec22'),
              ('Summary for equal-step methods', 2, None, '___sec23'),
              ("Lagrange's polynomial", 2, None, '___sec24'),
              ('Polynomial approximation', 2, None, '___sec25'),
              ('Gaussian Quadrature', 2, None, '___sec26'),
              ('Gaussian Quadrature, main idea', 2, None, '___sec27'),
              ('Gaussian Quadrature', 2, None, '___sec28'),
              ('Gaussian Quadrature, weight function', 2, None, '___sec29'),
              ('Gaussian Quadrature weights and integration points',
               2,
               None,
               '___sec30'),
              ('Gaussian Quadrature', 2, None, '___sec31'),
              ('Error in Gaussian Quadrature', 2, None, '___sec32'),
              ('Important polynomials in Gaussian Quadrature',
               2,
               None,
               '___sec33'),
              ('Gaussian Quadrature, win-win situation', 2, None, '___sec34'),
              ('Gaussian Quadrature, determining mesh points and weights',
               2,
               None,
               '___sec35'),
              ('Orthogonal polynomials, Legendre', 2, None, '___sec36'),
              ('Orthogonal polynomials, Legendre', 2, None, '___sec37'),
              ('Orthogonal polynomials, Legendre', 2, None, '___sec38'),
              ('Orthogonal polynomials, Legendre', 2, None, '___sec39'),
              ('Orthogonal polynomials, Legendre', 2, None, '___sec40'),
              ('Orthogonal polynomials, Legendre', 2, None, '___sec41'),
              ('Orthogonal polynomials, Legendre', 2, None, '___sec42'),
              ('Orthogonal polynomials, Legendre', 2, None, '___sec43'),
              ('Orthogonal polynomials, simple code for Legendre polynomials',
               2,
               None,
               '___sec44'),
              ('Integration points and weights with orthogonal polynomials',
               2,
               None,
               '___sec45'),
              ('Integration points and weights with orthogonal polynomials',
               2,
               None,
               '___sec46'),
              ('Integration points and weights with orthogonal polynomials',
               2,
               None,
               '___sec47'),
              ('Integration points and weights with orthogonal polynomials',
               2,
               None,
               '___sec48'),
              ('Integration points and weights with orthogonal polynomials',
               2,
               None,
               '___sec49'),
              ('Integration points and weights with orthogonal polynomials',
               2,
               None,
               '___sec50'),
              ('Integration points and weights with orthogonal polynomials',
               2,
               None,
               '___sec51'),
              ('Integration points and weights with orthogonal polynomials',
               2,
               None,
               '___sec52'),
              ('Integration points and weights with orthogonal polynomials',
               2,
               None,
               '___sec53'),
              ('Application to the case $N=2$', 2, None, '___sec54'),
              ('Application to the case $N=2$', 2, None, '___sec55'),
              ('Application to the case $N=2$', 2, None, '___sec56'),
              ('Application to the case $N=2$', 2, None, '___sec57'),
              ('Application to the case $N=2$', 2, None, '___sec58'),
              ('General integration intervals for Gauss-Legendre',
               2,
               None,
               '___sec59'),
              ('Mapping integration points and weights', 2, None, '___sec60'),
              ('Mapping integration points and weights', 2, None, '___sec61'),
              ('Other orthogonal polynomials, Laguerre polynomials',
               2,
               None,
               '___sec62'),
              ('Other orthogonal polynomials, Laguerre polynomials',
               2,
               None,
               '___sec63'),
              ('Other orthogonal polynomials, Laguerre polynomials',
               2,
               None,
               '___sec64'),
              ('Other orthogonal polynomials, Laguerre polynomials',
               2,
               None,
               '___sec65'),
              ('Other orthogonal polynomials, Hermite polynomials',
               2,
               None,
               '___sec66'),
              ('Other orthogonal polynomials, Hermite polynomials',
               2,
               None,
               '___sec67'),
              ('Demonstration of Gaussian Quadrature', 2, None, '___sec68'),
              ('Demonstration of Gaussian Quadrature, simple program',
               2,
               None,
               '___sec69'),
              ('Demonstration of Gaussian Quadrature', 2, None, '___sec70'),
              ('Demonstration of Gaussian Quadrature', 2, None, '___sec71'),
              ('Comparing methods and using symbolic Python',
               2,
               None,
               '___sec72'),
              ('Treatment of Singular Integrals', 2, None, '___sec73'),
              ('Treatment of Singular Integrals', 2, None, '___sec74'),
              ('Treatment of Singular Integrals, change of variables',
               2,
               None,
               '___sec75'),
              ('Treatment of Singular Integrals, higher-order derivatives',
               2,
               None,
               '___sec76'),
              ('Treatment of Singular Integrals', 2, None, '___sec77'),
              ('Treatment of Singular Integrals', 2, None, '___sec78'),
              ('Treatment of Singular Integrals', 2, None, '___sec79'),
              ('Treatment of Singular Integrals', 2, None, '___sec80'),
              ('Treatment of Singular Integrals', 2, None, '___sec81'),
              ('Treatment of Singular Integrals', 2, None, '___sec82'),
              ('Treatment of Singular Integrals', 2, None, '___sec83'),
              ('Treatment of Singular Integrals', 2, None, '___sec84'),
              ('Example of a multidimensional integral', 2, None, '___sec85'),
              ('Parts of code and brute force Gauss-Legendre quadrature',
               2,
               None,
               '___sec86'),
              ('The function to integrate, code example', 2, None, '___sec87'),
              ('Laguerre polynomials', 2, None, '___sec88'),
              ('Laguerre polynomials, the new integrand', 2, None, '___sec89'),
              ('Laguerre polynomials, new integration rule: Gauss-Laguerre',
               2,
               None,
               '___sec90'),
              ('Results with  $N=20$ with Gauss-Legendre', 2, None, '___sec91'),
              ('Results for  $r_{\\mathrm{max}}=2$ with Gauss-Legendre',
               2,
               None,
               '___sec92'),
              ('Results  with Gauss-Laguerre', 2, None, '___sec93')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "AMS"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript" async
 src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



    
<!-- Bootstrap navigation bar -->
<div class="navbar navbar-default navbar-fixed-top">
  <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="integrate-bs.html">Computational Physics Lectures: Numerical integration, from Newton-Cotes quadrature to Gaussian quadrature</a>
  </div>

  <div class="navbar-collapse collapse navbar-responsive-collapse">
    <ul class="nav navbar-nav navbar-right">
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Contents <b class="caret"></b></a>
        <ul class="dropdown-menu">
     <!-- navigation toc: --> <li><a href="#___sec0" style="font-size: 80%;">Numerical Integration</a></li>
     <!-- navigation toc: --> <li><a href="#___sec1" style="font-size: 80%;">Newton-Cotes Quadrature or equal-step methods</a></li>
     <!-- navigation toc: --> <li><a href="#___sec2" style="font-size: 80%;">Basic philosophy of equal-step methods</a></li>
     <!-- navigation toc: --> <li><a href="#___sec3" style="font-size: 80%;">Simple algorithm for equal step methods</a></li>
     <!-- navigation toc: --> <li><a href="#___sec4" style="font-size: 80%;">Simple algorithm for equal step methods</a></li>
     <!-- navigation toc: --> <li><a href="#___sec5" style="font-size: 80%;">Lagrange's interpolation formula</a></li>
     <!-- navigation toc: --> <li><a href="#___sec6" style="font-size: 80%;">Polynomial approximation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec7" style="font-size: 80%;">Simplifying the integral</a></li>
     <!-- navigation toc: --> <li><a href="#___sec8" style="font-size: 80%;">The trapezoidal rule</a></li>
     <!-- navigation toc: --> <li><a href="#___sec9" style="font-size: 80%;">Global error</a></li>
     <!-- navigation toc: --> <li><a href="#___sec10" style="font-size: 80%;">Error in the trapezoidal rule</a></li>
     <!-- navigation toc: --> <li><a href="#___sec11" style="font-size: 80%;">Algorithm for the trapezoidal rule</a></li>
     <!-- navigation toc: --> <li><a href="#___sec12" style="font-size: 80%;">Code example</a></li>
     <!-- navigation toc: --> <li><a href="#___sec13" style="font-size: 80%;">Transfer of  function names</a></li>
     <!-- navigation toc: --> <li><a href="#___sec14" style="font-size: 80%;">Going back to Python, why?</a></li>
     <!-- navigation toc: --> <li><a href="#___sec15" style="font-size: 80%;">Error analysis</a></li>
     <!-- navigation toc: --> <li><a href="#___sec16" style="font-size: 80%;">Integrating numerical mathematics with calculus</a></li>
     <!-- navigation toc: --> <li><a href="#___sec17" style="font-size: 80%;">The rectangle method</a></li>
     <!-- navigation toc: --> <li><a href="#___sec18" style="font-size: 80%;">Truncation error for the rectangular rule</a></li>
     <!-- navigation toc: --> <li><a href="#___sec19" style="font-size: 80%;">Second-order polynomial</a></li>
     <!-- navigation toc: --> <li><a href="#___sec20" style="font-size: 80%;">Simpson's rule</a></li>
     <!-- navigation toc: --> <li><a href="#___sec21" style="font-size: 80%;">Mathematical expressions for the truncation error</a></li>
     <!-- navigation toc: --> <li><a href="#___sec22" style="font-size: 80%;">Algorithm for Simpson's rule</a></li>
     <!-- navigation toc: --> <li><a href="#___sec23" style="font-size: 80%;">Summary for equal-step methods</a></li>
     <!-- navigation toc: --> <li><a href="#___sec24" style="font-size: 80%;">Lagrange's polynomial</a></li>
     <!-- navigation toc: --> <li><a href="#___sec25" style="font-size: 80%;">Polynomial approximation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec26" style="font-size: 80%;">Gaussian Quadrature</a></li>
     <!-- navigation toc: --> <li><a href="#___sec27" style="font-size: 80%;">Gaussian Quadrature, main idea</a></li>
     <!-- navigation toc: --> <li><a href="#___sec28" style="font-size: 80%;">Gaussian Quadrature</a></li>
     <!-- navigation toc: --> <li><a href="#___sec29" style="font-size: 80%;">Gaussian Quadrature, weight function</a></li>
     <!-- navigation toc: --> <li><a href="#___sec30" style="font-size: 80%;">Gaussian Quadrature weights and integration points</a></li>
     <!-- navigation toc: --> <li><a href="#___sec31" style="font-size: 80%;">Gaussian Quadrature</a></li>
     <!-- navigation toc: --> <li><a href="#___sec32" style="font-size: 80%;">Error in Gaussian Quadrature</a></li>
     <!-- navigation toc: --> <li><a href="#___sec33" style="font-size: 80%;">Important polynomials in Gaussian Quadrature</a></li>
     <!-- navigation toc: --> <li><a href="#___sec34" style="font-size: 80%;">Gaussian Quadrature, win-win situation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec35" style="font-size: 80%;">Gaussian Quadrature, determining mesh points and weights</a></li>
     <!-- navigation toc: --> <li><a href="#___sec36" style="font-size: 80%;">Orthogonal polynomials, Legendre</a></li>
     <!-- navigation toc: --> <li><a href="#___sec37" style="font-size: 80%;">Orthogonal polynomials, Legendre</a></li>
     <!-- navigation toc: --> <li><a href="#___sec38" style="font-size: 80%;">Orthogonal polynomials, Legendre</a></li>
     <!-- navigation toc: --> <li><a href="#___sec39" style="font-size: 80%;">Orthogonal polynomials, Legendre</a></li>
     <!-- navigation toc: --> <li><a href="#___sec40" style="font-size: 80%;">Orthogonal polynomials, Legendre</a></li>
     <!-- navigation toc: --> <li><a href="#___sec41" style="font-size: 80%;">Orthogonal polynomials, Legendre</a></li>
     <!-- navigation toc: --> <li><a href="#___sec42" style="font-size: 80%;">Orthogonal polynomials, Legendre</a></li>
     <!-- navigation toc: --> <li><a href="#___sec43" style="font-size: 80%;">Orthogonal polynomials, Legendre</a></li>
     <!-- navigation toc: --> <li><a href="#___sec44" style="font-size: 80%;">Orthogonal polynomials, simple code for Legendre polynomials</a></li>
     <!-- navigation toc: --> <li><a href="#___sec45" style="font-size: 80%;">Integration points and weights with orthogonal polynomials</a></li>
     <!-- navigation toc: --> <li><a href="#___sec46" style="font-size: 80%;">Integration points and weights with orthogonal polynomials</a></li>
     <!-- navigation toc: --> <li><a href="#___sec47" style="font-size: 80%;">Integration points and weights with orthogonal polynomials</a></li>
     <!-- navigation toc: --> <li><a href="#___sec48" style="font-size: 80%;">Integration points and weights with orthogonal polynomials</a></li>
     <!-- navigation toc: --> <li><a href="#___sec49" style="font-size: 80%;">Integration points and weights with orthogonal polynomials</a></li>
     <!-- navigation toc: --> <li><a href="#___sec50" style="font-size: 80%;">Integration points and weights with orthogonal polynomials</a></li>
     <!-- navigation toc: --> <li><a href="#___sec51" style="font-size: 80%;">Integration points and weights with orthogonal polynomials</a></li>
     <!-- navigation toc: --> <li><a href="#___sec52" style="font-size: 80%;">Integration points and weights with orthogonal polynomials</a></li>
     <!-- navigation toc: --> <li><a href="#___sec53" style="font-size: 80%;">Integration points and weights with orthogonal polynomials</a></li>
     <!-- navigation toc: --> <li><a href="#___sec54" style="font-size: 80%;">Application to the case \( N=2 \)</a></li>
     <!-- navigation toc: --> <li><a href="#___sec55" style="font-size: 80%;">Application to the case \( N=2 \)</a></li>
     <!-- navigation toc: --> <li><a href="#___sec56" style="font-size: 80%;">Application to the case \( N=2 \)</a></li>
     <!-- navigation toc: --> <li><a href="#___sec57" style="font-size: 80%;">Application to the case \( N=2 \)</a></li>
     <!-- navigation toc: --> <li><a href="#___sec58" style="font-size: 80%;">Application to the case \( N=2 \)</a></li>
     <!-- navigation toc: --> <li><a href="#___sec59" style="font-size: 80%;">General integration intervals for Gauss-Legendre</a></li>
     <!-- navigation toc: --> <li><a href="#___sec60" style="font-size: 80%;">Mapping integration points and weights</a></li>
     <!-- navigation toc: --> <li><a href="#___sec61" style="font-size: 80%;">Mapping integration points and weights</a></li>
     <!-- navigation toc: --> <li><a href="#___sec62" style="font-size: 80%;">Other orthogonal polynomials, Laguerre polynomials</a></li>
     <!-- navigation toc: --> <li><a href="#___sec63" style="font-size: 80%;">Other orthogonal polynomials, Laguerre polynomials</a></li>
     <!-- navigation toc: --> <li><a href="#___sec64" style="font-size: 80%;">Other orthogonal polynomials, Laguerre polynomials</a></li>
     <!-- navigation toc: --> <li><a href="#___sec65" style="font-size: 80%;">Other orthogonal polynomials, Laguerre polynomials</a></li>
     <!-- navigation toc: --> <li><a href="#___sec66" style="font-size: 80%;">Other orthogonal polynomials, Hermite polynomials</a></li>
     <!-- navigation toc: --> <li><a href="#___sec67" style="font-size: 80%;">Other orthogonal polynomials, Hermite polynomials</a></li>
     <!-- navigation toc: --> <li><a href="#___sec68" style="font-size: 80%;">Demonstration of Gaussian Quadrature</a></li>
     <!-- navigation toc: --> <li><a href="#___sec69" style="font-size: 80%;">Demonstration of Gaussian Quadrature, simple program</a></li>
     <!-- navigation toc: --> <li><a href="#___sec70" style="font-size: 80%;">Demonstration of Gaussian Quadrature</a></li>
     <!-- navigation toc: --> <li><a href="#___sec71" style="font-size: 80%;">Demonstration of Gaussian Quadrature</a></li>
     <!-- navigation toc: --> <li><a href="#___sec72" style="font-size: 80%;">Comparing methods and using symbolic Python</a></li>
     <!-- navigation toc: --> <li><a href="#___sec73" style="font-size: 80%;">Treatment of Singular Integrals</a></li>
     <!-- navigation toc: --> <li><a href="#___sec74" style="font-size: 80%;">Treatment of Singular Integrals</a></li>
     <!-- navigation toc: --> <li><a href="#___sec75" style="font-size: 80%;">Treatment of Singular Integrals, change of variables</a></li>
     <!-- navigation toc: --> <li><a href="#___sec76" style="font-size: 80%;">Treatment of Singular Integrals, higher-order derivatives</a></li>
     <!-- navigation toc: --> <li><a href="#___sec77" style="font-size: 80%;">Treatment of Singular Integrals</a></li>
     <!-- navigation toc: --> <li><a href="#___sec78" style="font-size: 80%;">Treatment of Singular Integrals</a></li>
     <!-- navigation toc: --> <li><a href="#___sec79" style="font-size: 80%;">Treatment of Singular Integrals</a></li>
     <!-- navigation toc: --> <li><a href="#___sec80" style="font-size: 80%;">Treatment of Singular Integrals</a></li>
     <!-- navigation toc: --> <li><a href="#___sec81" style="font-size: 80%;">Treatment of Singular Integrals</a></li>
     <!-- navigation toc: --> <li><a href="#___sec82" style="font-size: 80%;">Treatment of Singular Integrals</a></li>
     <!-- navigation toc: --> <li><a href="#___sec83" style="font-size: 80%;">Treatment of Singular Integrals</a></li>
     <!-- navigation toc: --> <li><a href="#___sec84" style="font-size: 80%;">Treatment of Singular Integrals</a></li>
     <!-- navigation toc: --> <li><a href="#___sec85" style="font-size: 80%;">Example of a multidimensional integral</a></li>
     <!-- navigation toc: --> <li><a href="#___sec86" style="font-size: 80%;">Parts of code and brute force Gauss-Legendre quadrature</a></li>
     <!-- navigation toc: --> <li><a href="#___sec87" style="font-size: 80%;">The function to integrate, code example</a></li>
     <!-- navigation toc: --> <li><a href="#___sec88" style="font-size: 80%;">Laguerre polynomials</a></li>
     <!-- navigation toc: --> <li><a href="#___sec89" style="font-size: 80%;">Laguerre polynomials, the new integrand</a></li>
     <!-- navigation toc: --> <li><a href="#___sec90" style="font-size: 80%;">Laguerre polynomials, new integration rule: Gauss-Laguerre</a></li>
     <!-- navigation toc: --> <li><a href="#___sec91" style="font-size: 80%;">Results with  \( N=20 \) with Gauss-Legendre</a></li>
     <!-- navigation toc: --> <li><a href="#___sec92" style="font-size: 80%;">Results for  \( r_{\mathrm{max}}=2 \) with Gauss-Legendre</a></li>
     <!-- navigation toc: --> <li><a href="#___sec93" style="font-size: 80%;">Results  with Gauss-Laguerre</a></li>

        </ul>
      </li>
    </ul>
  </div>
</div>
</div> <!-- end of navigation bar -->

<div class="container">

<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p> <!-- add vertical space -->

<!-- ------------------- main content ---------------------- -->



<div class="jumbotron">
<center><h1>Computational Physics Lectures: Numerical integration, from Newton-Cotes quadrature to Gaussian quadrature</h1></center>  <!-- document title -->

<p>
<!-- author(s): Morten Hjorth-Jensen -->

<center>
<b>Morten Hjorth-Jensen</b> [1, 2]
</center>

<p>
<!-- institution(s) -->

<center>[1] <b>Department of Physics, University of Oslo</b></center>
<center>[2] <b>Department of Physics and Astronomy and National Superconducting Cyclotron Laboratory, Michigan State University</b></center>
<br>
<p>
<center><h4>Jan 8, 2018</h4></center> <!-- date -->
<br>
<p>
<!-- potential-jumbotron-button -->
</div> <!-- end jumbotron -->

<!-- !split -->

<h2 id="___sec0" class="anchor">Numerical Integration </h2>
<div class="panel panel-default">
<div class="panel-body">
<p> <!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
Here we will  discuss some of the classical methods for integrating a function. The methods we discuss are  

<ol>
<li> Equal step methods like the trapezoidal, rectangular and Simpson's rule, parts of what are called Newton-Cotes quadrature methods.</li>
<li> Integration approaches   based on Gaussian quadrature.</li> 
</ol>

The latter are more suitable
for the case where the abscissas are not equally spaced. 
We emphasize methods for evaluating few-dimensional (typically up to four dimensions) integrals. Multi-dimensional integrals will be discussed in connection with Monte Carlo methods.
</div>
</div>


<p>
<!-- !split -->

<h2 id="___sec1" class="anchor">Newton-Cotes Quadrature or equal-step methods </h2>
<div class="panel panel-default">
<div class="panel-body">
<p> <!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
The integral 
$$
\begin{equation}
   I=\int_a^bf(x) dx
\label{eq:integraldef}
\end{equation}
$$

has a very simple meaning. The integral is the
area enscribed by the function \( f(x) \) starting from \( x=a \) to  \( x=b \). It is subdivided in several smaller areas whose evaluation is to  be approximated by different techniques. The areas under the curve can for example  be approximated by rectangular boxes or trapezoids.
</div>
</div>


<p>
<!-- !split  -->

<h2 id="___sec2" class="anchor">Basic philosophy of equal-step methods </h2>
<div class="panel panel-default">
<div class="panel-body">
<p> <!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
In considering equal step  methods, our basic approach is that of approximating
a function \( f(x) \) with a polynomial of at most 
degree \( N-1 \), given \( N \) integration points. If our polynomial is of degree \( 1 \),
the function will be approximated with \( f(x)\approx a_0+a_1x \).
</div>
</div>


<p>
<!-- !split  -->

<h2 id="___sec3" class="anchor">Simple algorithm for equal step methods </h2>
<div class="panel panel-default">
<div class="panel-body">
<p> <!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
The algorithm for these integration methods  is rather simple, and the number of approximations perhaps  unlimited!

<ul>
<li> Choose a step size \( h=(b-a)/N \)  where \( N \) is the number of steps and \( a \) and \( b \) the lower and upper limits of integration.</li>
<li> With a given step length we rewrite the integral as</li>  
</ul>

$$
\begin{equation*}     
\int_a^bf(x) dx= \int_a^{a+h}f(x)dx + \int_{a+h}^{a+2h}f(x)dx+\dots \int_{b-h}^{b}f(x)dx.
\end{equation*}
$$


<ul>
<li> The strategy then is to find a reliable polynomial approximation   for \( f(x) \) in the various intervals.  Choosing a given approximation for  \( f(x) \), we obtain a specific approximation to the  integral.</li>
<li> With this approximation to \( f(x) \) we perform the integration by computing the integrals over all subintervals.</li>
</ul>
</div>
</div>


<p>
<!-- !split  -->

<h2 id="___sec4" class="anchor">Simple algorithm for equal step methods </h2>
<div class="panel panel-default">
<div class="panel-body">
<p> <!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
One possible strategy then is to find a reliable polynomial expansion for \( f(x) \) in the smaller
subintervals. Consider for example evaluating
$$
\begin{equation*}
   \int_a^{a+2h}f(x)dx, 
\end{equation*}
$$

which we rewrite as
$$
\begin{equation}
   \int_a^{a+2h}f(x)dx=
 \int_{x_0-h}^{x_0+h}f(x)dx.
\label{eq:hhint}
\end{equation}
$$

We have chosen a midpoint \( x_0 \) and have defined \( x_0=a+h \).
</div>
</div>


<p>
<!-- !split  -->

<h2 id="___sec5" class="anchor">Lagrange's interpolation formula </h2>
<div class="panel panel-default">
<div class="panel-body">
<p> <!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
Using Lagrange's interpolation formula
$$
\begin{equation*}
   P_N(x)=\sum_{i=0}^{N}\prod_{k\ne i} \frac{x-x_k}{x_i-x_k}y_i,
\end{equation*}
$$

we could attempt to approximate the function \( f(x) \) with a first-order polynomial in \( x \) in the two
sub-intervals \( x\in[x_0-h,x_0] \) and \( x\in[x_0,x_0+h] \). A first order polynomial means simply that 
we have for say the interval  \( x\in[x_0,x_0+h] \)
$$
\begin{equation*}
   f(x)\approx P_1(x)=\frac{x-x_0}{(x_0+h)-x_0}f(x_0+h)+\frac{x-(x_0+h)}{x_0-(x_0+h)}f(x_0),
\end{equation*}
$$

and for the interval  \( x\in[x_0-h,x_0] \)
$$
\begin{equation*}
   f(x)\approx P_1(x)=\frac{x-(x_0-h)}{x_0-(x_0-h)}f(x_0)+\frac{x-x_0}{(x_0-h)-x_0}f(x_0-h).
\end{equation*}
$$
</div>
</div>


<p>
<!-- !split  -->

<h2 id="___sec6" class="anchor">Polynomial approximation </h2>
<div class="panel panel-default">
<div class="panel-body">
<p> <!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
Having performed this subdivision and polynomial approximation,
one from \( x_0-h \) to \( x_0 \) and the other from \( x_0 \) to \( x_0+h \),
$$
\begin{equation*}
   \int_a^{a+2h}f(x)dx=\int_{x_0-h}^{x_0}f(x)dx+\int_{x_0}^{x_0+h}f(x)dx,
\end{equation*}
$$

we can easily calculate for example the second integral as
$$
\begin{equation*}
\int_{x_0}^{x_0+h}f(x)dx\approx \int_{x_0}^{x_0+h}\left(\frac{x-x_0}{(x_0+h)-x_0}f(x_0+h)+\frac{x-(x_0+h)}{x_0-(x_0+h)}f(x_0)\right)dx.
\end{equation*}
$$
</div>
</div>


<p>
<!-- !split  -->

<h2 id="___sec7" class="anchor">Simplifying the integral </h2>
<div class="panel panel-default">
<div class="panel-body">
<p> <!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
This integral can be simplified to
$$
\begin{equation*}
\int_{x_0}^{x_0+h}f(x)dx\approx \int_{x_0}^{x_0+h}\left(\frac{x-x_0}{h}f(x_0+h)-\frac{x-(x_0+h)}{h}f(x_0)\right)dx,
\end{equation*}
$$

resulting in
$$
\begin{equation*}
\int_{x_0}^{x_0+h}f(x)dx=\frac{h}{2}\left(f(x_0+h) + f(x_0)\right)+O(h^3).
\end{equation*}
$$

Here we added the error made in approximating our integral 
with a polynomial of degree \( 1 \).
</div>
</div>


<p>
<!-- !split  -->

<h2 id="___sec8" class="anchor">The trapezoidal rule </h2>
<div class="panel panel-default">
<div class="panel-body">
<p> <!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
The other integral gives
$$
\begin{equation*}
\int_{x_0-h}^{x_0}f(x)dx=\frac{h}{2}\left(f(x_0) + f(x_0-h)\right)+O(h^3),
\end{equation*}
$$

and adding up we obtain
$$
\begin{equation}
   \int_{x_0-h}^{x_0+h}f(x)dx=\frac{h}{2}\left(f(x_0+h) + 2f(x_0) + f(x_0-h)\right)+O(h^3),
\label{eq:trapez}
\end{equation}
$$

which is the well-known trapezoidal rule.  Concerning the error in the approximation made,
\( O(h^3)=O((b-a)^3/N^3) \), you should  note 
that this is the local error.  Since we are splitting the integral from
\( a \) to \( b \) in \( N \) pieces, we will have to perform approximately \( N \) 
such operations.
</div>
</div>


<p>
<!-- !split  -->

<h2 id="___sec9" class="anchor">Global error </h2>
<div class="panel panel-default">
<div class="panel-body">
<p> <!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
This means that the <em>global error</em> goes like \( \approx O(h^2) \). 
The trapezoidal reads then
$$
\begin{equation}
   I=\int_a^bf(x) dx=h\left(f(a)/2 + f(a+h) +f(a+2h)+
                          \dots +f(b-h)+ f_{b}/2\right),
\label{eq:trapez1}
\end{equation}
$$

with a global error which goes like \( O(h^2) \).

<p>
Hereafter we use the shorthand notations \( f_{-h}=f(x_0-h) \), \( f_{0}=f(x_0) \)
and \( f_{h}=f(x_0+h) \).
</div>
</div>


<p>
<!-- !split  -->

<h2 id="___sec10" class="anchor">Error in the trapezoidal rule </h2>
<div class="panel panel-default">
<div class="panel-body">
<p> <!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
The correct mathematical expression for the local error for the trapezoidal rule is
$$
\begin{equation*}
\int_a^bf(x)dx -\frac{b-a}{2}\left[f(a)+f(b)\right]=-\frac{h^3}{12}f^{(2)}(\xi),
\end{equation*}
$$

and the global error reads
$$
\begin{equation*}
\int_a^bf(x)dx -T_h(f)=-\frac{b-a}{12}h^2f^{(2)}(\xi),
\end{equation*}
$$

where \( T_h \) is the trapezoidal result and \( \xi \in [a,b] \).
</div>
</div>


<p>
<!-- !split  -->

<h2 id="___sec11" class="anchor">Algorithm for the trapezoidal rule </h2>
<div class="panel panel-default">
<div class="panel-body">
<p> <!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
The trapezoidal rule is easy to  implement numerically 
through the following simple algorithm

<ul>
  <li> Choose the number of mesh points and fix the step length.</li>
  <li> calculate \( f(a) \) and \( f(b) \) and multiply with \( h/2 \).</li>
  <li> Perform a loop over \( n=1 \) to \( n-1 \) (\( f(a) \) and \( f(b) \) are known) and sum up  the terms \( f(a+h) +f(a+2h)+f(a+3h)+\dots +f(b-h) \). Each step in the loop  corresponds to a given value \( a+nh \).</li>
  <li> Multiply the final result by \( h \) and add \( hf(a)/2 \) and \( hf(b)/2 \).</li>
</ul>
</div>
</div>


<p>
<!-- !split  -->

<h2 id="___sec12" class="anchor">Code example  </h2>
<div class="panel panel-default">
<div class="panel-body">
<p> <!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
A simple function which implements this algorithm is as follows
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #B00040">double</span> <span style="color: #0000FF">TrapezoidalRule</span>(<span style="color: #B00040">double</span> a, <span style="color: #B00040">double</span> b, <span style="color: #B00040">int</span> n, <span style="color: #B00040">double</span> (<span style="color: #666666">*</span>func)(<span style="color: #B00040">double</span>))
{
      <span style="color: #B00040">double</span> TrapezSum;
      <span style="color: #B00040">double</span> fa, fb, x, step;
      <span style="color: #B00040">int</span>    j;
      step<span style="color: #666666">=</span>(b<span style="color: #666666">-</span>a)<span style="color: #666666">/</span>((<span style="color: #B00040">double</span>) n);
      fa<span style="color: #666666">=</span>(<span style="color: #666666">*</span>func)(a)<span style="color: #666666">/2.</span> ;
      fb<span style="color: #666666">=</span>(<span style="color: #666666">*</span>func)(b)<span style="color: #666666">/2.</span> ;
      TrapezSum<span style="color: #666666">=0.</span>;
      <span style="color: #008000; font-weight: bold">for</span> (j<span style="color: #666666">=1</span>; j <span style="color: #666666">&lt;=</span> n<span style="color: #666666">-1</span>; j<span style="color: #666666">++</span>){
         x<span style="color: #666666">=</span>j<span style="color: #666666">*</span>step<span style="color: #666666">+</span>a;
         TrapezSum<span style="color: #666666">+=</span>(<span style="color: #666666">*</span>func)(x);
      }
      TrapezSum<span style="color: #666666">=</span>(TrapezSum<span style="color: #666666">+</span>fb<span style="color: #666666">+</span>fa)<span style="color: #666666">*</span>step;
      <span style="color: #008000; font-weight: bold">return</span> TrapezSum;
}  <span style="color: #408080; font-style: italic">// end TrapezoidalRule </span>
</pre></div>
<p>
The function returns a new value for the specific integral through the variable <b>TrapezSum</b>.
</div>
</div>


<p>
<!-- !split  -->

<h2 id="___sec13" class="anchor">Transfer of  function names  </h2>
<div class="panel panel-default">
<div class="panel-body">
<p> <!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
There is one new feature to note here, namely
the transfer of a user defined function called <b>func</b> in the 
definition 
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>  <span style="color: #B00040">void</span> TrapezoidalRule(<span style="color: #B00040">double</span> a, <span style="color: #B00040">double</span> b, <span style="color: #B00040">int</span> n, <span style="color: #B00040">double</span> <span style="color: #666666">*</span>TrapezSum, <span style="color: #B00040">double</span> (<span style="color: #666666">*</span>func)(<span style="color: #B00040">double</span>) )  
</pre></div>
<p>
What happens here is that we are transferring a pointer to the name 
of a user defined function, which has as input a double precision variable and returns
a double precision number. The function  <b>TrapezoidalRule</b> is called as
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>  TrapezoidalRule(a, b, n, <span style="color: #666666">&amp;</span>MyFunction )       
</pre></div>
<p>
in the calling function. We note that <b>a</b>, <b>b</b> and <b>n</b> are called by value,
while <b>TrapezSum</b> and the user defined function <b>MyFunction</b>
are called by reference.
</div>
</div>


<p>
<!-- !split -->

<h2 id="___sec14" class="anchor">Going back to Python, why?  </h2>
<div class="panel panel-default">
<div class="panel-body">
<p> <!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
Python offers an  extremely versatile programming  environment, allowing for 
the inclusion of analytical studies in a numerical program. Here we show an
example code with the <b>trapezoidal rule</b> using <b>SymPy</b> to evaluate an integral and compute the absolute error
with respect to the numerically evaluated one of the integral
\( 4\int_0^1 dx/(1+x^2) = \pi \):
<p>


<div class="compute"><script type="text/x-sage">
from math import *
from sympy import *
def Trapez(a,b,f,n):
   h = (b-a)/float(n)
   s = 0
   x = a
   for i in range(1,n,1):
       x = x+h
       s = s+ f(x)
   s = 0.5*(f(a)+f(b)) +s
   return h*s

#  function to compute pi
def function(x):
    return 4.0/(1+x*x)

a = 0.0;  b = 1.0; n = 100
result = Trapez(a,b,function,n)
print "Trapezoidal rule=", result
# define x as a symbol to be used by sympy
x = Symbol('x')
exact = integrate(function(x), (x, 0.0, 1.0))
print "Sympy integration=", exact
# Find relative error
print "Relative error", abs((exact-result)/exact)

</script></div>
<p>
</div>
</div>


<p>
<!-- !split -->

<h2 id="___sec15" class="anchor">Error analysis </h2>
<div class="panel panel-default">
<div class="panel-body">
<p> <!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
The following extended version of the trapezoidal rule allows you  to plot the relative error by comparing with the exact result. By increasing to \( 10^8 \) points one arrives at a region where numerical errors start to accumulate.
<p>


<div class="compute"><script type="text/x-sage">
from math import log10
import numpy as np
from sympy import Symbol, integrate
import matplotlib.pyplot as plt
# function for the trapezoidal rule
def Trapez(a,b,f,n):
   h = (b-a)/float(n)
   s = 0
   x = a
   for i in range(1,n,1):
       x = x+h
       s = s+ f(x)
   s = 0.5*(f(a)+f(b)) +s
   return h*s
#  function to compute pi
def function(x):
    return 4.0/(1+x*x)
# define integration limits
a = 0.0;  b = 1.0;
# find result from sympy
# define x as a symbol to be used by sympy
x = Symbol('x')
exact = integrate(function(x), (x, a, b))
# set up the arrays for plotting the relative error
n = np.zeros(9); y = np.zeros(9);
# find the relative error as function of integration points
for i in range(1, 8, 1):
    npts = 10**i
    result = Trapez(a,b,function,npts)
    RelativeError = abs((exact-result)/exact)
    n[i] = log10(npts); y[i] = log10(RelativeError);
plt.plot(n,y, 'ro')
plt.xlabel('n')
plt.ylabel('Relative error')
plt.show()

</script></div>
<p>
</div>
</div>


<p>
<!-- !split -->

<h2 id="___sec16" class="anchor">Integrating numerical mathematics with calculus </h2>
<div class="panel panel-default">
<div class="panel-body">
<p> <!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
The last example shows the potential of combining numerical algorithms with 
symbolic calculations, allowing us thereby to

<ul>
<li> Validate and verify  our  algorithms.</li>
<li> Including concepts like unit testing, one has the possibility to test and  validate several or all parts of the code.</li>
<li> Validation and verification are then included <em>naturally</em>.</li>
<li> The above example allows you to test the mathematical error of the algorithm for the trapezoidal rule by changing the number of integration points. You get trained from day one to think error analysis.</li>
</ul>
</div>
</div>


<p>
<!-- !split  -->

<h2 id="___sec17" class="anchor">The rectangle method </h2>
<div class="panel panel-default">
<div class="panel-body">
<p> <!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
Another very simple approach is the so-called midpoint or rectangle method.
In this case the integration area is split in a given number of rectangles with length \( h \) and height given by the mid-point value of the function.  This gives the following simple rule for approximating an integral
$$
\begin{equation}
   I=\int_a^bf(x) dx \approx  h\sum_{i=1}^N f(x_{i-1/2}), 
\label{eq:rectangle}
\end{equation}
$$

where \( f(x_{i-1/2}) \) is the midpoint value of \( f \) for a given rectangle. We will discuss its truncation 
error below.  It is easy to implement this algorithm,  as shown here
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #B00040">double</span> <span style="color: #0000FF">RectangleRule</span>(<span style="color: #B00040">double</span> a, <span style="color: #B00040">double</span> b, <span style="color: #B00040">int</span> n, <span style="color: #B00040">double</span> (<span style="color: #666666">*</span>func)(<span style="color: #B00040">double</span>))
{
      <span style="color: #B00040">double</span> RectangleSum;
      <span style="color: #B00040">double</span> fa, fb, x, step;
      <span style="color: #B00040">int</span>    j;
      step<span style="color: #666666">=</span>(b<span style="color: #666666">-</span>a)<span style="color: #666666">/</span>((<span style="color: #B00040">double</span>) n);
      RectangleSum<span style="color: #666666">=0.</span>;
      <span style="color: #008000; font-weight: bold">for</span> (j <span style="color: #666666">=</span> <span style="color: #666666">0</span>; j <span style="color: #666666">&lt;=</span> n; j<span style="color: #666666">++</span>){
         x <span style="color: #666666">=</span> (j<span style="color: #666666">+0.5</span>)<span style="color: #666666">*</span>step<span style="color: #666666">+</span>;   <span style="color: #408080; font-style: italic">// midpoint of a given rectangle</span>
         RectangleSum<span style="color: #666666">+=</span>(<span style="color: #666666">*</span>func)(x);   <span style="color: #408080; font-style: italic">//  add value of function.</span>
      }
      RectangleSum <span style="color: #666666">*=</span> step;  <span style="color: #408080; font-style: italic">//  multiply with step length.</span>
      <span style="color: #008000; font-weight: bold">return</span> RectangleSum;
}  <span style="color: #408080; font-style: italic">// end RectangleRule </span>
</pre></div>
<p>
</div>
</div>


<p>
<!-- !split  -->

<h2 id="___sec18" class="anchor">Truncation error for the rectangular rule  </h2>
<div class="panel panel-default">
<div class="panel-body">
<p> <!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
The correct mathematical expression for the local error for the rectangular rule \( R_i(h) \) for element \( i \) is

$$
\begin{equation*}
\int_{-h}^hf(x)dx - R_i(h)=-\frac{h^3}{24}f^{(2)}(\xi),
\end{equation*}
$$

and the global error reads
$$
\begin{equation*}
\int_a^bf(x)dx -R_h(f)=-\frac{b-a}{24}h^2f^{(2)}(\xi),
\end{equation*}
$$

where \( R_h \) is the result obtained with rectangular rule and \( \xi \in [a,b] \).
</div>
</div>


<p>
<!-- !split  -->

<h2 id="___sec19" class="anchor">Second-order polynomial </h2>
<div class="panel panel-default">
<div class="panel-body">
<p> <!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
Instead of using the above first-order polynomials 
approximations for \( f \), we attempt at using a second-order polynomials.
In this case we need three points in order to define a second-order 
polynomial approximation
$$
\begin{equation*}
f(x) \approx P_2(x)=a_0+a_1x+a_2x^2.
\end{equation*}
$$

Using again Lagrange's interpolation formula we have
$$
\begin{equation*}
     P_2(x)=\frac{(x-x_0)(x-x_1)}{(x_2-x_0)(x_2-x_1)}y_2+
            \frac{(x-x_0)(x-x_2)}{(x_1-x_0)(x_1-x_2)}y_1+
            \frac{(x-x_1)(x-x_2)}{(x_0-x_1)(x_0-x_2)}y_0.
\end{equation*}
$$

Inserting this formula in the integral of Eq.  \eqref{eq:hhint} we obtain
$$
\begin{equation*}
   \int_{-h}^{+h}f(x)dx=\frac{h}{3}\left(f_h + 4f_0 + f_{-h}\right)+O(h^5),
\end{equation*}
$$

which is Simpson's rule.
</div>
</div>


<p>
<!-- !split  -->

<h2 id="___sec20" class="anchor">Simpson's rule </h2>
<div class="panel panel-default">
<div class="panel-body">
<p> <!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
Note that the improved accuracy in the evaluation of
the derivatives gives a better error approximation, \( O(h^5) \) vs.\ \( O(h^3) \) .
But this is again the <em>local error approximation</em>. 
Using Simpson's rule we can easily compute
the integral     of Eq.  \eqref{eq:integraldef} to be
$$
\begin{equation}
   I=\int_a^bf(x) dx=\frac{h}{3}\left(f(a) + 4f(a+h) +2f(a+2h)+
                          \dots +4f(b-h)+ f_{b}\right),
\label{eq:simpson}
\end{equation}
$$

with a global error which goes like \( O(h^4) \).
</div>
</div>


<p>
<!-- !split  -->

<h2 id="___sec21" class="anchor">Mathematical expressions for the truncation error </h2>
<div class="panel panel-default">
<div class="panel-body">
<p> <!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
More formal expressions for the local and global errors are for the local error
$$
\begin{equation*}
\int_a^bf(x)dx -\frac{b-a}{6}\left[f(a)+4f((a+b)/2)+f(b)\right]=-\frac{h^5}{90}f^{(4)}(\xi),
\end{equation*}
$$

and for the global error
$$
\begin{equation*}
\int_a^bf(x)dx -S_h(f)=-\frac{b-a}{180}h^4f^{(4)}(\xi).
\end{equation*}
$$

with \( \xi\in[a,b] \) and \( S_h \) the results obtained with Simpson's method.
</div>
</div>


<p>
<!-- !split  -->

<h2 id="___sec22" class="anchor">Algorithm for Simpson's rule </h2>
<div class="panel panel-default">
<div class="panel-body">
<p> <!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
The method 
can easily be implemented numerically through the following simple algorithm

<ul>
  <li> Choose the number of mesh points and fix the step.</li>
  <li> calculate \( f(a) \) and \( f(b) \)</li>
  <li> Perform a loop over \( n=1 \) to \( n-1 \) (\( f(a) \) and \( f(b) \) are known) and sum up   the terms \( 4f(a+h) +2f(a+2h)+4f(a+3h)+\dots +4f(b-h) \). Each step in the loop  corresponds to a given value \( a+nh \). Odd values of \( n \) give \( 4 \) as factor  while even values yield \( 2 \) as factor.</li>
  <li> Multiply the final result by \( \frac{h}{3} \).</li>
</ul>
</div>
</div>


<p>
<!-- !split  -->

<h2 id="___sec23" class="anchor">Summary for equal-step methods </h2>
<div class="panel panel-default">
<div class="panel-body">
<p> <!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
In more general terms, what we have done here is to approximate a given function \( f(x) \) with a polynomial
of a certain degree. One can show that 
given \( n+1 \) distinct points \( x_0,\dots, x_n\in[a,b] \) and \( n+1 \) values \( y_0,\dots,y_n \) there exists a 
unique polynomial \( P_n(x) \) with the property
$$
\begin{equation*}
   P_n(x_j) = y_j\hspace{0.5cm} j=0,\dots,n
\end{equation*}
$$
</div>
</div>


<p>
<!-- !split  -->

<h2 id="___sec24" class="anchor">Lagrange's polynomial </h2>
<div class="panel panel-default">
<div class="panel-body">
<p> <!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
In the Lagrange representation the interpolating polynomial is given by
$$
\begin{equation*}
P_n = \sum_{k=0}^nl_ky_k,
\end{equation*}
$$

with the Lagrange factors
$$
\begin{equation*}
   l_k(x) = \prod_{\begin{array}{c}i=0 \\ i\ne k\end{array}}^n\frac{x-x_i}{x_k-x_i}\hspace{0.2cm} k=0,\dots,n.
\end{equation*}
$$
</div>
</div>


<p>
<!-- !split  -->

<h2 id="___sec25" class="anchor">Polynomial approximation </h2>
<div class="panel panel-default">
<div class="panel-body">
<p> <!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
If we for example set \( n=1 \), we obtain
$$
\begin{equation*}
P_1(x) = y_0\frac{x-x_1}{x_0-x_1}+y_1\frac{x-x_0}{x_1-x_0}=\frac{y_1-y_0}{x_1-x_0}x-\frac{y_1x_0+y_0x_1}{x_1-x_0},
\end{equation*}
$$

which we recognize as the equation for a straight line.

<p>
The polynomial interpolatory quadrature of order \( n \) with equidistant quadrature points \( x_k=a+kh \)
and step \( h=(b-a)/n \) is called the Newton-Cotes quadrature formula of order \( n \).

<p>
</div>
</div>


<p>
<!-- !split -->

<h2 id="___sec26" class="anchor">Gaussian Quadrature </h2>
<div class="panel panel-default">
<div class="panel-body">
<p> <!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
The methods we have presented hitherto are tailored to problems where the 
mesh points \( x_i \) are equidistantly spaced, \( x_i \) differing from \( x_{i+1} \) by the step \( h \).

<p>
The basic idea behind all integration methods is to approximate the integral
$$
\begin{equation*} 
   I=\int_a^bf(x)dx \approx \sum_{i=1}^N\omega_if(x_i),  
\end{equation*}
$$

where \( \omega \) and \( x \) are the weights and the chosen mesh points, respectively.
In our previous discussion, these mesh points were fixed at the beginning, by choosing
a given number of points \( N \). The weigths \( \omega \) resulted then from the integration
method we applied. Simpson's rule, see Eq.  \eqref{eq:simpson} would give
$$
\begin{equation*}
   \omega : \left\{h/3,4h/3,2h/3,4h/3,\dots,4h/3,h/3\right\},
\end{equation*}
$$

for the weights, while the trapezoidal rule resulted in
$$
\begin{equation*}
   \omega : \left\{h/2,h,h,\dots,h,h/2\right\}.
\end{equation*}
$$
</div>
</div>


<p>
<!-- !split -->

<h2 id="___sec27" class="anchor">Gaussian Quadrature, main idea </h2>
<div class="panel panel-default">
<div class="panel-body">
<p> <!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
In general, an integration formula which is based on a Taylor series using \( N \) points,
will integrate exactly a polynomial \( P \) of degree \( N-1 \). That is, the \( N \) weights
\( \omega_n \) can be chosen to satisfy \( N \) linear equations, see chapter 3 of Ref.\ [3]. 
A greater precision for a given amount of numerical work can  be achieved
if we are willing to give up the requirement of equally spaced integration points.  
In Gaussian quadrature (hereafter GQ), both the mesh points and the weights are to
be determined. The points will not be equally spaced.

<p>
The theory behind GQ is to obtain an arbitrary weight \( \omega \) through the use of
so-called orthogonal polynomials. These polynomials are orthogonal in some
interval say e.g., [-1,1]. Our points \( x_i \) are chosen in some optimal sense subject
only to the constraint that they should lie in this interval. Together with the weights
we have then \( 2N \) (\( N \) the number of points) parameters at our disposal.
</div>
</div>


<p>
<!-- !split -->

<h2 id="___sec28" class="anchor">Gaussian Quadrature </h2>
<div class="panel panel-default">
<div class="panel-body">
<p> <!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
Even though the integrand is not smooth, we could render it smooth by extracting
from it the weight function of an orthogonal polynomial, i.e.,
we are rewriting
$$
\begin{equation}
   I= \int_a^b f(x)dx =\int_a^b W(x)g(x)dx \approx \sum_{i=1}^N\omega_ig(x_i),  
\label{eq:generalint}
\end{equation}
$$

where \( g \) is smooth and \( W \) is the weight function, which is to  be associated with a given 
orthogonal polynomial. Note that with a given weight function we end up evaluating the integrand
for the function \( g(x_i) \).
</div>
</div>


<p>
<!-- !split -->

<h2 id="___sec29" class="anchor">Gaussian Quadrature, weight function </h2>
<div class="panel panel-default">
<div class="panel-body">
<p> <!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
The weight function \( W \) is non-negative in the integration interval 
\( x\in [a,b] \) such that
for any \( n \ge 0 \), the integral \( \int_a^b |x|^n W(x) dx \) is integrable. The naming
weight function arises from the fact that it may be used to give more emphasis
to one part of the interval than another. 
A quadrature formula 
$$
\begin{equation} 
   \int_a^b W(x)f(x)dx \approx \sum_{i=1}^N\omega_if(x_i), 
\label{_auto1}
\end{equation} 
$$

with \( N \) distinct quadrature points (mesh points) is a called a Gaussian quadrature 
formula if it integrates all polynomials \( p\in P_{2N-1} \) exactly, that is
$$
\begin{equation} 
\int_a^bW(x)p(x)dx =\sum_{i=1}^N\omega_ip(x_i), 
\label{_auto2}
\end{equation}
$$

It is assumed that \( W(x) \) is continuous and positive and that the integral
$$
\begin{equation*} 
\int_a^bW(x)dx
\end{equation*}
$$

exists. Note that the replacement of \( f\rightarrow Wg \) is normally a better approximation
due to the fact that we may isolate possible singularities of \( W \) and its 
derivatives at the endpoints of the interval.
</div>
</div>


<p>
<!-- !split -->

<h2 id="___sec30" class="anchor">Gaussian Quadrature weights and integration points </h2>
<div class="panel panel-default">
<div class="panel-body">
<p> <!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
The quadrature weights or just weights (not to be confused with the weight function) 
are positive and the sequence of Gaussian quadrature formulae is convergent 
if the sequence \( Q_N \) of quadrature formulae
$$
\begin{equation*}
   Q_N(f)\rightarrow Q(f)=\int_a^bf(x)dx,
\end{equation*}
$$

in the limit \( N\rightarrow \infty \).
</div>
</div>


<p>
<!-- !split -->

<h2 id="___sec31" class="anchor">Gaussian Quadrature </h2>
<div class="panel panel-default">
<div class="panel-body">
<p> <!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
Then  we say that the sequence
$$
\begin{equation*} 
Q_N(f) = \sum_{i=1}^N\omega_i^{(N)}f(x_i^{(N)}), 
\end{equation*}
$$

is convergent for all polynomials \( p \), that is
$$
\begin{equation*}
Q_N(p) = Q(p) 
\end{equation*}
$$

if there exits a constant \( C \) such that
$$
\begin{equation*}
 \sum_{i=1}^N|\omega_i^{(N)}| \le C,
\end{equation*}
$$

for all \( N \) which are natural numbers.
</div>
</div>


<p>
<!-- !split -->

<h2 id="___sec32" class="anchor">Error in Gaussian Quadrature </h2>
<div class="panel panel-default">
<div class="panel-body">
<p> <!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
The error for the Gaussian quadrature formulae of order \( N \) is given
by

$$
\begin{equation*}
  \int_a^bW(x)f(x)dx-\sum_{k=1}^Nw_kf(x_k)=\frac{f^{2N}(\xi)}{(2N)!}\int_a^bW(x)[q_{N}(x)]^2dx
\end{equation*}
$$

where \( q_{N} \) is the chosen orthogonal polynomial and \( \xi \) is a number in the interval \( [a,b] \).
We have assumed that \( f\in C^{2N}[a,b] \), viz. the space of all real or complex  \( 2N \) times continuously
differentiable functions.
</div>
</div>


<p>
<!-- !split -->

<h2 id="___sec33" class="anchor">Important polynomials in Gaussian Quadrature </h2>
<div class="panel panel-default">
<div class="panel-body">
<p> <!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
In science there are several important orthogonal polynomials which arise
from the solution of differential equations. Well-known examples are the  
Legendre, Hermite, Laguerre and Chebyshev polynomials. They have the following weight functions

<p>

<div class="row">
  <div class="col-xs-8">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="center"><b>      Weight function      </b></td> <td align="center"><b>           Interval           </b></td> <td align="center"><b>Polynomial</b></td> </tr>
</thead>
<tbody>
<tr><td align="right">   \( W(x)=1 \)                   </td> <td align="right">   \( x\in [-1,1] \)                 </td> <td align="right">   Legendre      </td> </tr>
<tr><td align="right">   \( W(x)=e^{-x^2} \)            </td> <td align="right">   \( -\infty \le x \le \infty \)    </td> <td align="right">   Hermite       </td> </tr>
<tr><td align="right">   \( W(x)=x^{\alpha}e^{-x} \)    </td> <td align="right">   \( 0 \le x \le \infty \)          </td> <td align="right">   Laguerre      </td> </tr>
<tr><td align="right">   \( W(x)=1/(\sqrt{1-x^2}) \)    </td> <td align="right">   \( -1 \le x \le 1 \)              </td> <td align="right">   Chebyshev     </td> </tr>
</tbody>
    </table>
  </div> <!-- col-xs-8 -->
</div> <!-- cell row -->
<p>
The importance of the use of orthogonal polynomials in the evaluation
of integrals can be summarized as follows.
</div>
</div>


<p>
<!-- !split -->

<h2 id="___sec34" class="anchor">Gaussian Quadrature, win-win situation </h2>
<div class="panel panel-default">
<div class="panel-body">
<p> <!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->

<p>
Methods based on Taylor series using \( N \) points will  integrate exactly a polynomial \( P \) of degree \( N-1 \). If a function \( f(x) \) can be approximated with a polynomial of degree \( N-1 \)          
$$
\begin{equation*}            
f(x)\approx P_{N-1}(x),
\end{equation*}
$$

with \( N \) mesh points we should be able to integrate exactly the polynomial \( P_{N-1} \).

<p>
Gaussian quadrature methods promise more than this. We can get a better          polynomial approximation with order greater than \( N \)  to \( f(x) \) and still          get away with only \( N \) mesh points. More precisely, we approximate           
$$
\begin{equation*}             
f(x) \approx P_{2N-1}(x),
\end{equation*}
$$

and with only \( N \) mesh points these methods promise that
$$
\begin{equation*}
            \int f(x)dx \approx \int P_{2N-1}(x)dx=\sum_{i=0}^{N-1} P_{2N-1}(x_i)\omega_i,
\end{equation*}
$$
</div>
</div>


<p>
<!-- !split -->

<h2 id="___sec35" class="anchor">Gaussian Quadrature, determining mesh points and weights </h2>
<div class="panel panel-default">
<div class="panel-body">
<p> <!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->

<p>
The reason why we can represent a function \( f(x) \) with a polynomial of degree
\( 2N-1 \) is due to the fact that we have \( 2N \) equations, \( N \) for the mesh points and \( N \)
for the weights.

<p>
<em>The mesh points are the zeros  of the chosen  orthogonal polynomial</em> of
order \( N \), and the weights are determined from the inverse of a matrix.
An orthogonal polynomials of degree \( N \) defined in an interval \( [a,b] \)
has precisely \( N \) distinct zeros on the open interval \( (a,b) \).

<p>
Before we detail how to obtain mesh points and weights with orthogonal 
polynomials, let us revisit some features of orthogonal polynomials
by specializing to Legendre polynomials. In the text below, we reserve 
hereafter the labelling
\( L_N \) for a Legendre polynomial of order \( N \), while \( P_N \) is an arbitrary polynomial
of order \( N \). 
These polynomials form then the basis for the Gauss-Legendre method.
</div>
</div>


<p>
<!-- !split -->

<h2 id="___sec36" class="anchor">Orthogonal polynomials, Legendre </h2>

<p>
The Legendre polynomials are the solutions of an important
differential equation in Science, namely

$$
\begin{equation*}
C(1-x^2)P-m_l^2P+(1-x^2)\frac{d}{dx}\left((1-x^2)\frac{dP}{dx}\right)=0.
\end{equation*}
$$

Here \( C \) is a constant. For \( m_l=0 \) we obtain the Legendre polynomials
as solutions, whereas \( m_l \ne 0 \) yields the so-called associated Legendre
polynomials. This differential equation arises in for example the solution
of the angular dependence of Schroedinger's 
equation with spherically symmetric potentials such as
the Coulomb potential.

<p>
<!-- !split -->

<h2 id="___sec37" class="anchor">Orthogonal polynomials, Legendre </h2>
The corresponding polynomials \( P \) are
$$
\begin{equation*}
   L_k(x)=\frac{1}{2^kk!}\frac{d^k}{dx^k}(x^2-1)^k \hspace{1cm} k=0,1,2,\dots,
\end{equation*}
$$

which, up to a factor, are the Legendre polynomials \( L_k \). 
The latter fulfil the orthogonality relation
$$
\begin{equation} 
  \int_{-1}^1L_i(x)L_j(x)dx=\frac{2}{2i+1}\delta_{ij},
\label{eq:ortholeg}
\end{equation} 
$$

and the recursion relation
$$
\begin{equation} 
  (j+1)L_{j+1}(x)+jL_{j-1}(x)-(2j+1)xL_j(x)=0.
\label{eq:legrecur}
\end{equation} 
$$

<p>
<!-- !split -->

<h2 id="___sec38" class="anchor">Orthogonal polynomials, Legendre </h2>
It is common to choose the normalization condition
$$
\begin{equation*}
    L_N(1)=1.
\end{equation*}
$$

With these equations we can determine a Legendre polynomial of arbitrary order
with input polynomials of order \( N-1 \) and \( N-2 \).

<p>
As an example, consider the determination of \( L_0 \), \( L_1 \) and \( L_2 \). 
We have that
$$
\begin{equation*}
   L_0(x) = c,
\end{equation*}
$$

with \( c \) a constant. Using the normalization equation \( L_0(1)=1 \)
we get that

$$
\begin{equation*}
   L_0(x) = 1.
\end{equation*}
$$

<p>
<!-- !split -->

<h2 id="___sec39" class="anchor">Orthogonal polynomials, Legendre </h2>
For \( L_1(x) \) we have the general expression
$$
\begin{equation*}
   L_1(x) = a+bx,
\end{equation*}
$$

and using the orthogonality relation
$$
\begin{equation*}
  \int_{-1}^1L_0(x)L_1(x)dx=0,
\end{equation*}
$$

we obtain \( a=0 \) and with the condition \( L_1(1)=1 \), we obtain \( b=1 \), yielding
$$
\begin{equation*}
   L_1(x) = x.
\end{equation*}
$$

<p>
<!-- !split -->

<h2 id="___sec40" class="anchor">Orthogonal polynomials, Legendre </h2>
We can proceed in a similar fashion in order to determine
the coefficients of \( L_2 \)
$$
\begin{equation*}
   L_2(x) = a+bx+cx^2,
\end{equation*}
$$

using the orthogonality relations
$$
\begin{equation*}
  \int_{-1}^1L_0(x)L_2(x)dx=0,
\end{equation*}
$$

and
$$
\begin{equation*}
  \int_{-1}^1L_1(x)L_2(x)dx=0,
\end{equation*}
$$

and the condition
\( L_2(1)=1 \) we would get 
$$
\begin{equation}
   L_2(x) = \frac{1}{2}\left(3x^2-1\right).
\label{eq:l2}
\end{equation}
$$

<p>
<!-- !split -->

<h2 id="___sec41" class="anchor">Orthogonal polynomials, Legendre </h2>
We note that we have three equations to determine the three coefficients
\( a \), \( b \) and \( c \).

<p>
Alternatively, we could have 
employed the recursion relation of Eq. \eqref{eq:legrecur}, resulting in

$$
\begin{equation*}
   2L_2(x)=3xL_1(x)-L_0,
\end{equation*}
$$

which leads to Eq. \eqref{eq:l2}.

<p>
<!-- !split -->

<h2 id="___sec42" class="anchor">Orthogonal polynomials, Legendre </h2>
The orthogonality relation above is important in our discussion
on how to obtain the weights and mesh points. Suppose we have an arbitrary
polynomial \( Q_{N-1} \) of order \( N-1 \) and a Legendre polynomial \( L_N(x) \) of
order \( N \). We could represent \( Q_{N-1} \) 
by the Legendre polynomials through 
$$
\begin{equation}
   Q_{N-1}(x)=\sum_{k=0}^{N-1}\alpha_kL_{k}(x),
\label{eq:legexpansion}
\end{equation}
$$

where \( \alpha_k \)'s are constants.

<p>
Using the orthogonality relation of Eq. \eqref{eq:ortholeg} we see that
$$
\begin{equation}
  \int_{-1}^1L_N(x)Q_{N-1}(x)dx=\sum_{k=0}^{N-1} \int_{-1}^1L_N(x) \alpha_kL_{k}(x)dx=0.
\label{eq:ortholeg2}
\end{equation}
$$

We will use this result in our construction of mesh points and weights 
in the next subsection.

<p>
<!-- !split -->

<h2 id="___sec43" class="anchor">Orthogonal polynomials, Legendre </h2>
In summary, the first few Legendre polynomials are
$$
\begin{equation*}
   L_0(x) =1,
\end{equation*}
$$

$$
\begin{equation*}
  L_1(x) = x,
\end{equation*}
$$

$$
\begin{equation*}
  L_2(x) = (3x^2-1)/2,
\end{equation*}
$$

$$
\begin{equation*}
   L_3(x) = (5x^3-3x)/2,
\end{equation*}
$$

and
$$
\begin{equation*}
   L_4(x) = (35x^4-30x^2+3)/8.
\end{equation*}
$$

<p>
<!-- !split -->

<h2 id="___sec44" class="anchor">Orthogonal polynomials, simple code for Legendre polynomials </h2>
The following simple function implements the above recursion relation
of Eq. \eqref{eq:legrecur}.
for computing Legendre polynomials of order \( N \).
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #408080; font-style: italic">//  This function computes the Legendre polynomial of degree N</span>

<span style="color: #B00040">double</span> <span style="color: #0000FF">Legendre</span>( <span style="color: #B00040">int</span> n, <span style="color: #B00040">double</span> x) 
{
       <span style="color: #B00040">double</span> r, s, t;
       <span style="color: #B00040">int</span> m;
       r <span style="color: #666666">=</span> <span style="color: #666666">0</span>; s <span style="color: #666666">=</span> <span style="color: #666666">1.</span>;
       <span style="color: #408080; font-style: italic">//  Use recursion relation to generate p1 and p2</span>
       <span style="color: #008000; font-weight: bold">for</span> (m<span style="color: #666666">=0</span>; m <span style="color: #666666">&lt;</span> n; m<span style="color: #666666">++</span> )  
       {
          t <span style="color: #666666">=</span> r; r <span style="color: #666666">=</span> s; 
          s <span style="color: #666666">=</span> (<span style="color: #666666">2*</span>m<span style="color: #666666">+1</span>)<span style="color: #666666">*</span>x<span style="color: #666666">*</span>r <span style="color: #666666">-</span> m<span style="color: #666666">*</span>t;
          s <span style="color: #666666">/=</span> (m<span style="color: #666666">+1</span>);
	} <span style="color: #408080; font-style: italic">// end of do loop </span>
        <span style="color: #008000; font-weight: bold">return</span> s;
}   <span style="color: #408080; font-style: italic">// end of function Legendre</span>
</pre></div>
<p>
The variable \( s \) represents \( L_{j+1}(x) \), while \( r \) holds
\( L_j(x) \) and \( t \) the value \( L_{j-1}(x) \).

<p>
<!-- !split -->

<h2 id="___sec45" class="anchor">Integration points and weights with orthogonal polynomials </h2>

<p>
To understand how the weights and the mesh points are generated, we define first
a polynomial of degree \( 2N-1 \) (since we have \( 2N \) variables at hand, the mesh points
and weights for \( N \) points). This polynomial can be represented through polynomial
division by

$$
\begin{equation*}
   P_{2N-1}(x)=L_N(x)P_{N-1}(x)+Q_{N-1}(x),
\end{equation*}
$$

where \( P_{N-1}(x) \) and \( Q_{N-1}(x) \) are some polynomials of degree \( N-1 \) or less.
The function \( L_N(x) \) is a Legendre polynomial of order \( N \).

<p>
Recall that we wanted to approximate  an arbitrary function \( f(x) \) with a
polynomial \( P_{2N-1} \) in order to evaluate

$$
\begin{equation*}
   \int_{-1}^1f(x)dx\approx \int_{-1}^1P_{2N-1}(x)dx.
\end{equation*}
$$

<p>
<!-- !split -->

<h2 id="___sec46" class="anchor">Integration points and weights with orthogonal polynomials </h2>
We can use Eq. \eqref{eq:ortholeg2}
to rewrite the above integral as
$$
\begin{equation*} 
   \int_{-1}^1P_{2N-1}(x)dx=\int_{-1}^1(L_N(x)P_{N-1}(x)+Q_{N-1}(x))dx=\int_{-1}^1Q_{N-1}(x)dx,
\end{equation*}
$$

due to the orthogonality properties of the Legendre polynomials. We see that it suffices
to evaluate the integral over \( \int_{-1}^1Q_{N-1}(x)dx \) in order to evaluate 
\( \int_{-1}^1P_{2N-1}(x)dx \). In addition, at the points \( x_k \) where \( L_N \) is zero, we have

$$
\begin{equation*}
    P_{2N-1}(x_k)=Q_{N-1}(x_k)\hspace{1cm} k=0,1,\dots, N-1,
\end{equation*}
$$

and we see that through these \( N \) points we can fully define \( Q_{N-1}(x) \)  and thereby the 
integral. Note that we have chosen to let the numbering of the points run from \( 0 \) to \( N-1 \).
The reason for this choice is that we wish to have the same numbering as the order of a 
polynomial of degree \( N-1 \).  This numbering will be useful below when  we introduce the matrix
elements  which define the integration weights \( w_i \).

<p>
<!-- !split -->

<h2 id="___sec47" class="anchor">Integration points and weights with orthogonal polynomials </h2>
We develope then \( Q_{N-1}(x) \) in terms of Legendre polynomials,
as done in Eq. \eqref{eq:legexpansion}, 
$$
\begin{equation} 
  Q_{N-1}(x)=\sum_{i=0}^{N-1}\alpha_iL_i(x).
\label{eq:lsum1}
\end{equation}
$$

Using the orthogonality property of the Legendre polynomials we have
$$
\begin{equation*} 
  \int_{-1}^1Q_{N-1}(x)dx=\sum_{i=0}^{N-1}\alpha_i\int_{-1}^1L_0(x)L_i(x)dx=2\alpha_0,
\end{equation*}
$$

where we have just inserted \( L_0(x)=1 \)!

<p>
<!-- !split -->

<h2 id="___sec48" class="anchor">Integration points and weights with orthogonal polynomials </h2>
Instead of an integration problem we need now to define the coefficient \( \alpha_0 \).
Since we know the values of \( Q_{N-1} \) at the zeros of \( L_N \), we may rewrite  
Eq.  \eqref{eq:lsum1} as
$$
\begin{equation} 
  Q_{N-1}(x_k)=\sum_{i=0}^{N-1}\alpha_iL_i(x_k)=\sum_{i=0}^{N-1}\alpha_iL_{ik} \hspace{1cm} k=0,1,\dots, N-1.
\label{eq:lsum2}
\end{equation}
$$

Since the Legendre polynomials are linearly independent of each other, none 
of the columns in the matrix \( L_{ik} \) are linear combinations of the others.

<p>
<!-- !split -->

<h2 id="___sec49" class="anchor">Integration points and weights with orthogonal polynomials </h2>
This means that the matrix \( L_{ik} \) has an inverse with the properties
$$
\begin{equation*}
   \hat{L}^{-1}\hat{L} = \hat{I}.
\end{equation*}
$$

Multiplying both sides of Eq. \eqref{eq:lsum2} with \( \sum_{j=0}^{N-1}L_{ji}^{-1} \) results in 
$$
\begin{equation}
  \sum_{i=0}^{N-1}(L^{-1})_{ki}Q_{N-1}(x_i)=\alpha_k.
\label{eq:lsum3}
\end{equation}
$$

<p>
<!-- !split -->

<h2 id="___sec50" class="anchor">Integration points and weights with orthogonal polynomials </h2>
We can derive this result in an alternative way by defining the vectors
$$
\begin{equation*}
\hat{x}_k=\left(\begin{array} {c} x_0\\
                                x_1\\
                                .\\
                                .\\
                                x_{N-1}\end{array}\right) \hspace{0.5cm}
\hat{\alpha}=\left(\begin{array} {c} \alpha_0\\
                                \alpha_1\\
                                .\\
                                .\\
                                \alpha_{N-1}\end{array}\right),
\end{equation*}
$$

and the matrix
$$
\begin{equation*}
   \hat{L}=\left(\begin{array} {cccc} L_0(x_0)  & L_1(x_0) &\dots &L_{N-1}(x_0)\\
                                   L_0(x_1)  & L_1(x_1) &\dots &L_{N-1}(x_1)\\
                                   \dots  & \dots &\dots &\dots\\
L_0(x_{N-1})  & L_1(x_{N-1}) &\dots &L_{N-1}(x_{N-1})
\end{array}\right).
\end{equation*}
$$

<p>
<!-- !split -->

<h2 id="___sec51" class="anchor">Integration points and weights with orthogonal polynomials </h2>
We have then
$$
\begin{equation*}
Q_{N-1}(\hat{x}_k) = \hat{L}\hat{\alpha},
\end{equation*}
$$

yielding (if \( \hat{L} \) has an inverse)
$$
\begin{equation*}
\hat{L}^{-1}Q_{N-1}(\hat{x}_k) = \hat{\alpha},
\end{equation*}
$$

which is Eq. \eqref{eq:lsum3}.

<p>
<!-- !split -->

<h2 id="___sec52" class="anchor">Integration points and weights with orthogonal polynomials </h2>
Using the above results and the fact that
$$
\begin{equation*} 
   \int_{-1}^1P_{2N-1}(x)dx=\int_{-1}^1Q_{N-1}(x)dx,
\end{equation*}
$$

we get
$$
\begin{equation*} 
   \int_{-1}^1P_{2N-1}(x)dx=\int_{-1}^1Q_{N-1}(x)dx=2\alpha_0=
   2\sum_{i=0}^{N-1}(L^{-1})_{0i}P_{2N-1}(x_i).
\end{equation*}
$$

<p>
<!-- !split -->

<h2 id="___sec53" class="anchor">Integration points and weights with orthogonal polynomials </h2>
If we identify the weights with \( 2(L^{-1})_{0i} \), where the points \( x_i \) are
the zeros of \( L_N \), we have an integration formula of the type
$$
\begin{equation*}
   \int_{-1}^1P_{2N-1}(x)dx=\sum_{i=0}^{N-1}\omega_iP_{2N-1}(x_i)  
\end{equation*}
$$

and if our function \( f(x) \)  can be approximated by a polynomial \( P \) of degree
\( 2N-1 \), we have finally that
$$
\begin{equation*}
    \int_{-1}^1f(x)dx\approx \int_{-1}^1P_{2N-1}(x)dx=\sum_{i=0}^{N-1}\omega_iP_{2N-1}(x_i)  .
\end{equation*}
$$

In summary, the mesh points \( x_i \) are defined by the zeros of an orthogonal polynomial of degree \( N \), that is 
\( L_N \), while the weights are
given by \( 2(L^{-1})_{0i} \).

<p>
<!-- !split -->

<h2 id="___sec54" class="anchor">Application to the case \( N=2 \) </h2>

<p>
Let us apply the above formal results to the case \( N=2 \). 
This means that we can approximate a function \( f(x) \) with a
polynomial \( P_3(x) \) of order \( 2N-1=3 \).

<p>
The mesh points are the zeros of \( L_2(x)=1/2(3x^2-1) \). 
These points are \( x_0=-1/\sqrt{3} \) and \( x_1=1/\sqrt{3} \).

<p>
Specializing Eq. \eqref{eq:lsum2}

$$
\begin{equation*} 
  Q_{N-1}(x_k)=\sum_{i=0}^{N-1}\alpha_iL_i(x_k) \hspace{1cm} k=0,1,\dots, N-1.
\end{equation*}
$$

to \( N=2 \) yields

$$
\begin{equation*}
   Q_1(x_0)=\alpha_0-\alpha_1\frac{1}{\sqrt{3}},
\end{equation*}
$$

and

$$
\begin{equation*}
   Q_1(x_1)=\alpha_0+\alpha_1\frac{1}{\sqrt{3}},
\end{equation*}
$$

since \( L_0(x=\pm 1/\sqrt{3})=1 \) and \( L_1(x=\pm 1/\sqrt{3})=\pm 1/\sqrt{3} \).

<p>
<!-- !split -->

<h2 id="___sec55" class="anchor">Application to the case \( N=2 \) </h2>
The matrix \( L_{ik} \) defined in Eq. \eqref{eq:lsum2} is then

$$
\begin{equation*}
   \hat{L}=\left(\begin{array} {cc} 1  & -\frac{1}{\sqrt{3}}\\
                                   1  & \frac{1}{\sqrt{3}}\end{array}\right),
\end{equation*}
$$

with an inverse given by

$$
\begin{equation*}
   \hat{L}^{-1}=\frac{\sqrt{3}}{2}\left(\begin{array} {cc} \frac{1}{\sqrt{3}}  & \frac{1}{\sqrt{3}}\\
                                   -1  & 1\end{array}\right).
\end{equation*}
$$

The weights are given by the matrix elements \( 2(L_{0k})^{-1} \). We have thence
\( \omega_0=1 \) and \( \omega_1=1 \).

<p>
<!-- !split -->

<h2 id="___sec56" class="anchor">Application to the case \( N=2 \) </h2>
Obviously, there is no problem in changing the numbering of the matrix elements \( i,k=0,1,2,\dots,N-1 \) to
\( i,k=1,2,\dots,N \).  We have chosen to start from zero, since we deal with polynomials of degree \( N-1 \).

<p>
Summarizing, for Legendre polynomials with \( N=2 \) we have
weights
$$
\begin{equation*}
   \omega : \left\{1,1\right\},
\end{equation*}
$$

and mesh points

$$
\begin{equation*}
   x : \left\{-\frac{1}{\sqrt{3}},\frac{1}{\sqrt{3}}\right\}.
\end{equation*}
$$

<p>
<!-- !split -->

<h2 id="___sec57" class="anchor">Application to the case \( N=2 \) </h2>
If we wish to integrate
$$
\begin{equation*}
   \int_{-1}^1f(x)dx,
\end{equation*}
$$

with \( f(x)=x^2 \), we approximate
$$
\begin{equation*} 
   I=\int_{-1}^1x^2dx \approx \sum_{i=0}^{N-1}\omega_ix_i^2.  
\end{equation*}
$$

<p>
<!-- !split -->

<h2 id="___sec58" class="anchor">Application to the case \( N=2 \) </h2>
The exact answer is \( 2/3 \). Using \( N=2 \) with the above two weights 
and mesh points we get

$$
\begin{equation*} 
   I=\int_{-1}^1x^2dx =\sum_{i=0}^{1}\omega_ix_i^2=\frac{1}{3}+\frac{1}{3}=\frac{2}{3},  
\end{equation*}
$$

the exact answer!

<p>
If we were to emply the trapezoidal rule we would get

$$
\begin{equation*} 
   I=\int_{-1}^1x^2dx =\frac{b-a}{2}\left((a)^2+(b)^2\right)/2=
                       \frac{1-(-1)}{2}\left((-1)^2+(1)^2\right)/2=1!
\end{equation*}
$$

With just two points we can calculate exactly the integral for a second-order
polynomial since our methods approximates the exact function with higher
order polynomial. 
How many points do you need with the trapezoidal rule in order to achieve a
similar accuracy?

<p>
<!-- !split -->

<h2 id="___sec59" class="anchor">General integration intervals for Gauss-Legendre </h2>

<p>
Note that the Gauss-Legendre method is not limited
to an interval [-1,1], since we can always through a change of variable
$$
\begin{equation*}
   t=\frac{b-a}{2}x+\frac{b+a}{2},
\end{equation*}
$$

rewrite  the integral for an interval  [a,b]

$$
\begin{equation*}
  \int_a^bf(t)dt=\frac{b-a}{2}\int_{-1}^1f\left(\frac{(b-a)x}{2}+\frac{b+a}{2}\right)dx.
\end{equation*}
$$

<p>
<!-- !split -->

<h2 id="___sec60" class="anchor">Mapping integration points and weights </h2>
If we have an integral on the form
$$
\begin{equation*}
  \int_0^{\infty}f(t)dt,
\end{equation*}
$$

we can choose new mesh points and weights by using the mapping

$$
\begin{equation*}
\tilde{x}_i=tan\left\{\frac{\pi}{4}(1+x_i)\right\},
\end{equation*}
$$

and

$$
\begin{equation*}
\tilde{\omega}_i= \frac{\pi}{4}\frac{\omega_i}{cos^2\left(\frac{\pi}{4}(1+x_i)\right)},
\end{equation*}
$$

where \( x_i \) and \( \omega_i \) are the original mesh points and weights in the 
interval \( [-1,1] \), while \( \tilde{x}_i \) and \( \tilde{\omega}_i \) are the new
mesh points and weights for the interval \( [0,\infty) \).

<p>
<!-- !split -->

<h2 id="___sec61" class="anchor">Mapping integration points and weights </h2>
To see  that this is correct by inserting the 
the value of \( x_i=-1 \) (the lower end of the interval \( [-1,1] \))
into the expression for \( \tilde{x}_i \). That gives \( \tilde{x}_i=0 \),
the lower end of the interval \( [0,\infty) \). For
\( x_i=1 \), we obtain \( \tilde{x}_i=\infty \). To check that the new
weights are correct, recall that the weights should correspond to the 
derivative of the mesh points. Try to convince yourself that the
above expression fulfills this condition.

<p>
<!-- !split -->

<h2 id="___sec62" class="anchor">Other orthogonal polynomials, Laguerre polynomials </h2>

<p>
If we are able to rewrite our integral of Eq.  \eqref{eq:generalint} with a
weight function \( W(x)=x^{\alpha}e^{-x} \) with integration limits 
\( [0,\infty) \), we could then use the Laguerre polynomials.
The polynomials form then the basis for the Gauss-Laguerre method which can be applied
to integrals of the form

$$
\begin{equation*} 
   I=\int_0^{\infty}f(x)dx =\int_0^{\infty}x^{\alpha}e^{-x}g(x)dx.
\end{equation*}
$$

<p>
<!-- !split -->

<h2 id="___sec63" class="anchor">Other orthogonal polynomials, Laguerre polynomials </h2>
These polynomials arise from the solution of the differential
equation

$$
\begin{equation*}
\left(\frac{d^2 }{dx^2}-\frac{d }{dx}+\frac{\lambda}{x}-\frac{l(l+1)}{x^2}\right){\cal L}(x)=0,
\end{equation*}
$$

where \( l \) is an integer \( l\ge 0 \) and \( \lambda \) a constant. This equation
arises for example from the solution of the radial Schr\"odinger equation with 
a centrally symmetric potential such as the Coulomb potential.

<p>
<!-- !split -->

<h2 id="___sec64" class="anchor">Other orthogonal polynomials, Laguerre polynomials </h2>
The first few polynomials are
$$
\begin{equation*}
   {\cal L}_0(x)=1,
\end{equation*}
$$

$$
\begin{equation*}
    {\cal L}_1(x)=1-x,
\end{equation*}
$$

$$
\begin{equation*}
    {\cal L}_2(x)=2-4x+x^2,
\end{equation*}
$$

$$
\begin{equation*}
    {\cal L}_3(x)=6-18x+9x^2-x^3,
\end{equation*}
$$

and
$$
\begin{equation*}
    {\cal L}_4(x)=x^4-16x^3+72x^2-96x+24.
\end{equation*}
$$

<p>
<!-- !split -->

<h2 id="___sec65" class="anchor">Other orthogonal polynomials, Laguerre polynomials </h2>
They fulfil the orthogonality relation
$$
\begin{equation*}
  \int_{0}^{\infty}e^{-x}{\cal L}_n(x)^2dx=1,
\end{equation*}
$$

and the recursion relation
$$
\begin{equation*}
  (n+1){\cal L}_{n+1}(x)=(2n+1-x){\cal L}_{n}(x)-n{\cal L}_{n-1}(x).
\end{equation*}
$$

<p>
<!-- !split -->

<h2 id="___sec66" class="anchor">Other orthogonal polynomials, Hermite polynomials </h2>

<p>
In a similar way, for an integral which goes like
$$
\begin{equation*} 
   I=\int_{-\infty}^{\infty}f(x)dx =\int_{-\infty}^{\infty}e^{-x^2}g(x)dx.
\end{equation*}
$$

we could use the Hermite polynomials in order to extract weights and mesh points.
The Hermite polynomials are the solutions of the following differential
equation

$$
\begin{equation}
   \frac{d^2H(x)}{dx^2}-2x\frac{dH(x)}{dx}+
       (\lambda-1)H(x)=0.
\label{eq:hermite}
\end{equation}
$$

<p>
<!-- !split -->

<h2 id="___sec67" class="anchor">Other orthogonal polynomials, Hermite polynomials </h2>
A typical example is again the solution of Schrodinger's
equation, but this time with a harmonic oscillator potential.
The first few polynomials are
$$
\begin{equation*}
   H_0(x)=1,
\end{equation*}
$$

$$
\begin{equation*}
    H_1(x)=2x,
\end{equation*}
$$

$$
\begin{equation*}
    H_2(x)=4x^2-2,
\end{equation*}
$$

$$
\begin{equation*}
    H_3(x)=8x^3-12,
\end{equation*}
$$

and
$$
\begin{equation*}
    H_4(x)=16x^4-48x^2+12.
\end{equation*}
$$

They fulfil the orthogonality relation
$$
\begin{equation*}
  \int_{-\infty}^{\infty}e^{-x^2}H_n(x)^2dx=2^nn!\sqrt{\pi},
\end{equation*}
$$

and the recursion relation
$$
\begin{equation*}
  H_{n+1}(x)=2xH_{n}(x)-2nH_{n-1}(x).
\end{equation*}
$$

<p>
<!-- !split  -->

<h2 id="___sec68" class="anchor">Demonstration of Gaussian Quadrature </h2>
Let us here compare three methods for integrating, namely the trapezoidal rule,
Simpson's method and the Gauss-Legendre approach. 
We choose two functions to integrate:
$$
\begin{equation*}
  \int_1^{100}\frac{\exp{(-x)}}{x}dx,
\end{equation*}
$$

and

$$
\begin{equation*}
  \int_{0}^{3}\frac{1}{2+x^2}dx.
\end{equation*}
$$

<p>
<!-- !split  -->

<h2 id="___sec69" class="anchor">Demonstration of Gaussian Quadrature, simple program </h2>
A program example which uses the trapezoidal rule, Simpson's rule
and the Gauss-Legendre method is included here. 
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #BC7A00">#include</span> <span style="color: #408080; font-style: italic">&lt;iostream&gt;</span><span style="color: #BC7A00"></span>
<span style="color: #BC7A00">#include</span> <span style="color: #408080; font-style: italic">&quot;lib.h&quot;</span><span style="color: #BC7A00"></span>
<span style="color: #008000; font-weight: bold">using</span> <span style="color: #008000; font-weight: bold">namespace</span> std;
<span style="color: #408080; font-style: italic">//     Here we define various functions called by the main program</span>
<span style="color: #408080; font-style: italic">//     this function defines the function to integrate</span>
<span style="color: #B00040">double</span> <span style="color: #0000FF">int_function</span>(<span style="color: #B00040">double</span> x);
<span style="color: #408080; font-style: italic">//   Main function begins here</span>
<span style="color: #B00040">int</span> <span style="color: #0000FF">main</span>()
{
     <span style="color: #B00040">int</span> n;
     <span style="color: #B00040">double</span> a, b;
     cout <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot;Read in the number of integration points&quot;</span> <span style="color: #666666">&lt;&lt;</span> endl;
     cin <span style="color: #666666">&gt;&gt;</span> n;
     cout <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot;Read in integration limits&quot;</span> <span style="color: #666666">&lt;&lt;</span> endl;
     cin <span style="color: #666666">&gt;&gt;</span> a <span style="color: #666666">&gt;&gt;</span> b;
<span style="color: #408080; font-style: italic">//   reserve space in memory for vectors containing the mesh points</span>
<span style="color: #408080; font-style: italic">//   weights and function values for the use of the gauss-legendre</span>
<span style="color: #408080; font-style: italic">//   method</span>
     <span style="color: #B00040">double</span> <span style="color: #666666">*</span>x <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">new</span> <span style="color: #B00040">double</span> [n];
     <span style="color: #B00040">double</span> <span style="color: #666666">*</span>w <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">new</span> <span style="color: #B00040">double</span> [n];
<span style="color: #408080; font-style: italic">//   set up the mesh points and weights</span>
     gauss_legendre(a, b,x,w, n);
<span style="color: #408080; font-style: italic">//   evaluate the integral with the Gauss-Legendre method</span>
<span style="color: #408080; font-style: italic">//   Note that we initialize the sum</span>
     <span style="color: #B00040">double</span> int_gauss <span style="color: #666666">=</span> <span style="color: #666666">0.</span>;
     <span style="color: #008000; font-weight: bold">for</span> ( <span style="color: #B00040">int</span> i <span style="color: #666666">=</span> <span style="color: #666666">0</span>;  i <span style="color: #666666">&lt;</span> n; i<span style="color: #666666">++</span>){
        int_gauss<span style="color: #666666">+=</span>w[i]<span style="color: #666666">*</span>int_function(x[i]);
     }
<span style="color: #408080; font-style: italic">//    final output</span>
      cout <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot;Trapez-rule = &quot;</span> <span style="color: #666666">&lt;&lt;</span> trapezoidal_rule(a, b,n, int_function)
           <span style="color: #666666">&lt;&lt;</span> endl;
      cout <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot;Simpson&#39;s rule = &quot;</span> <span style="color: #666666">&lt;&lt;</span> simpson(a, b,n, int_function) 
           <span style="color: #666666">&lt;&lt;</span> endl;
      cout <span style="color: #666666">&lt;&lt;</span> <span style="color: #BA2121">&quot;Gaussian quad = &quot;</span> <span style="color: #666666">&lt;&lt;</span> int_gauss <span style="color: #666666">&lt;&lt;</span> endl;
      <span style="color: #008000; font-weight: bold">delete</span> [] x;
      <span style="color: #008000; font-weight: bold">delete</span> [] w;
      <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">0</span>;
}  <span style="color: #408080; font-style: italic">// end of main program</span>
<span style="color: #408080; font-style: italic">//  this function defines the function to integrate</span>
<span style="color: #B00040">double</span> <span style="color: #0000FF">int_function</span>(<span style="color: #B00040">double</span> x)
{
  <span style="color: #B00040">double</span> value <span style="color: #666666">=</span> <span style="color: #666666">4./</span>(<span style="color: #666666">1.+</span>x<span style="color: #666666">*</span>x);
  <span style="color: #008000; font-weight: bold">return</span> value;
} <span style="color: #408080; font-style: italic">// end of function to evaluate</span>
</pre></div>
<p>
<!-- !split  -->

<h2 id="___sec70" class="anchor">Demonstration of Gaussian Quadrature </h2>
To be noted in this program is that we can transfer the name of a given function to integrate.
In the table here we show the results for the first integral using various 
mesh points,.

<p>

<div class="row">
  <div class="col-xs-4">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="center">\( N \)</td> <td align="center"><b> Trapez </b></td> <td align="center"><b>Simpson </b></td> <td align="center"><b>Gauss-Legendre</b></td> </tr>
</thead>
<tbody>
<tr><td align="right">   10         </td> <td align="left">   1.821020    </td> <td align="left">   1.214025    </td> <td align="left">   0.1460448         </td> </tr>
<tr><td align="right">   20         </td> <td align="left">   0.912678    </td> <td align="left">   0.609897    </td> <td align="left">   0.2178091         </td> </tr>
<tr><td align="right">   40         </td> <td align="left">   0.478456    </td> <td align="left">   0.333714    </td> <td align="left">   0.2193834         </td> </tr>
<tr><td align="right">   100        </td> <td align="left">   0.273724    </td> <td align="left">   0.231290    </td> <td align="left">   0.2193839         </td> </tr>
<tr><td align="right">   1000       </td> <td align="left">   0.219984    </td> <td align="left">   0.219387    </td> <td align="left">   0.2193839         </td> </tr>
</tbody>
    </table>
  </div> <!-- col-xs-4 -->
</div> <!-- cell row -->
<p>
We note here that, since the area over where we integrate is rather large and the integrand 
goes slowly to zero for large values of \( x \), both the trapezoidal rule and Simpson's method
need quite many points in order to approach the Gauss-Legendre method. 
This integrand demonstrates clearly the strength of the Gauss-Legendre method
(and other GQ methods as well), viz., few points
are needed in order to achieve a very high precision.

<p>
<!-- !split  -->

<h2 id="___sec71" class="anchor">Demonstration of Gaussian Quadrature </h2>
The second table however shows that for smaller integration intervals, both the trapezoidal rule
and Simpson's method compare well with the results obtained with the Gauss-Legendre
approach.

<p>

<div class="row">
  <div class="col-xs-4">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="center">\( N \)</td> <td align="center"><b> Trapez </b></td> <td align="center"><b>Simpson </b></td> <td align="center"><b>Gauss-Legendre</b></td> </tr>
</thead>
<tbody>
<tr><td align="right">   10         </td> <td align="left">   0.798861    </td> <td align="left">   0.799231    </td> <td align="left">   0.799233          </td> </tr>
<tr><td align="right">   20         </td> <td align="left">   0.799140    </td> <td align="left">   0.799233    </td> <td align="left">   0.799233          </td> </tr>
<tr><td align="right">   40         </td> <td align="left">   0.799209    </td> <td align="left">   0.799233    </td> <td align="left">   0.799233          </td> </tr>
<tr><td align="right">   100        </td> <td align="left">   0.799229    </td> <td align="left">   0.799233    </td> <td align="left">   0.799233          </td> </tr>
<tr><td align="right">   1000       </td> <td align="left">   0.799233    </td> <td align="left">   0.799233    </td> <td align="left">   0.799233          </td> </tr>
</tbody>
    </table>
  </div> <!-- col-xs-4 -->
</div> <!-- cell row -->
<p>
<!-- !split -->

<h2 id="___sec72" class="anchor">Comparing methods and using symbolic Python </h2>
<div class="panel panel-default">
<div class="panel-body">
<p> <!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
The following python code allows you to run interactively either in a browser or using ipython notebook. It compares the trapezoidal rule and Gaussian quadrature with the exact result from symbolic python <b>SYMPY</b> up to 1000 integration points for the integral
$$
I = 2 = \int_0^{\infty} x^2 \exp{-x} dx.
$$

For the trapezoidal rule the results will vary strongly depending on how the infinity limit is approximated. Try to run the code below for different finite approximations to \( \infty \).
<p>


<div class="compute"><script type="text/x-sage">
from math import exp
import numpy as np
from sympy import Symbol, integrate, exp, oo

# function for the trapezoidal rule
def TrapezoidalRule(a,b,f,n):
   h = (b-a)/float(n)
   s = 0
   x = a
   for i in range(1,n,1):
       x = x+h
       s = s+ f(x)
   s = 0.5*(f(a)+f(b)) +s
   return h*s

# function for the Gaussian quadrature with Laguerre polynomials
def GaussLaguerreRule(n):
   s = 0
   xgauleg, wgauleg = np.polynomial.laguerre.laggauss(n)
   for i in range(1,n,1):
       s = s+ xgauleg[i]*xgauleg[i]*wgauleg[i]
   return s

#  function to compute
def function(x):
    return x*x*exp(-x)


# Integration limits for the Trapezoidal rule
a = 0.0; b = 10000.0
# define x as a symbol to be used by sympy
x = Symbol('x')
# find result from sympy
exact = integrate(function(x), (x, a, oo))
# set up the arrays for plotting the relative error
n = np.zeros(40); Trapez = np.zeros(4); LagGauss = np.zeros(4);
# find the relative error as function of integration points
for i in range(1, 3, 1):
    npts = 10**i
    n[i] = npts
    Trapez[i] = abs((TrapezoidalRule(a,b,function,npts)-exact)/exact)
    LagGauss[i] = abs((GaussLaguerreRule(npts)-exact)/exact)
print "Integration points=", n[1], n[2]
print "Trapezoidal relative error=", Trapez[1], Trapez[2]
print "LagGuass relative error=", LagGauss[1], LagGauss[2]



</script></div>
<p>
</div>
</div>


<p>
<!-- !split -->

<h2 id="___sec73" class="anchor">Treatment of Singular Integrals </h2>
<div class="panel panel-default">
<div class="panel-body">
<p> <!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
So-called principal value (PV) integrals are often employed in physics,
from Green's functions for scattering to dispersion relations.
Dispersion relations are often related to measurable quantities
and provide important consistency checks in atomic, nuclear and
particle physics. 
A PV integral is defined as
$$
\begin{equation*}
   I(x)={\cal P}\int_a^bdt\frac{f(t)}{t-x}=\lim_{\epsilon\rightarrow 0^+}
\left[\int_a^{x-\epsilon}dt\frac{f(t)}{t-x}+\int_{x+\epsilon}^bdt\frac{f(t)}{t-x}\right],
\end{equation*}
$$

and 
arises in applications
of Cauchy's residue theorem when the pole \( x \)  lies 
on the real axis within the interval of integration \( [a,b] \). Here \( {\cal P} \) stands for the principal value. <em>An important assumption is that the function \( f(t) \) is continuous 
on the interval of integration</em>.
</div>
</div>


<p>
<!-- !split -->

<h2 id="___sec74" class="anchor">Treatment of Singular Integrals </h2>
<div class="panel panel-default">
<div class="panel-body">
<p> <!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
In case \( f(t) \) is a closed form expression or it has an analytic continuation
in the complex plane, it may be  possible to obtain an expression on closed
form for the above integral.

<p>
However, the situation which we are often confronted with is that
\( f(t) \) is only known at some points \( t_i \) with corresponding
values \( f(t_i) \). In order to obtain \( I(x) \) we need to resort to a
numerical evaluation.

<p>
To evaluate such an integral, let us first rewrite it as
$$
\begin{equation*}
 {\cal P}\int_a^bdt\frac{f(t)}{t-x}=
\int_a^{x-\Delta}dt\frac{f(t)}{t-x}+\int_{x+\Delta}^bdt\frac{f(t)}{t-x}+
{\cal P}\int_{x-\Delta}^{x+\Delta}dt\frac{f(t)}{t-x},
\end{equation*}
$$

where we have isolated the principal value part in the last integral.
</div>
</div>


<p>
<!-- !split -->

<h2 id="___sec75" class="anchor">Treatment of Singular Integrals, change of variables </h2>
<div class="panel panel-default">
<div class="panel-body">
<p> <!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
Defining a new variable \( u=t-x \), we can rewrite the principal value
integral as
$$
\begin{equation} 
I_{\Delta}(x)={\cal P}\int_{-\Delta}^{+\Delta}du\frac{f(u+x)}{u}.
\label{eq:deltaint}
\end{equation} 
$$

One possibility is to Taylor expand \( f(u+x) \) around \( u=0 \), and compute
derivatives to a certain order as we did for the Trapezoidal rule or
Simpson's rule. 
Since all terms with even powers of \( u \) in the Taylor expansion dissapear,
we have that
$$
\begin{equation*}
I_{\Delta}(x)\approx \sum_{n=0}^{N_{max}}f^{(2n+1)}(x)
                     \frac{\Delta^{2n+1}}{(2n+1)(2n+1)!}.
\end{equation*}
$$
</div>
</div>


<p>
<!-- !split -->

<h2 id="___sec76" class="anchor">Treatment of Singular Integrals, higher-order derivatives </h2>
<div class="panel panel-default">
<div class="panel-body">
<p> <!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
To evaluate higher-order derivatives may be both time 
consuming and delicate from a numerical point of view, since 
there is always the risk of loosing precision when calculating
derivatives numerically. Unless we have an analytic expression
for \( f(u+x) \) and can evaluate the derivatives in a closed form,
the above approach is not the preferred one.

<p>
Rather, we show here how to use the Gauss-Legendre method
to compute Eq. \eqref{eq:deltaint}. 
Let us first introduce a new variable \( s=u/\Delta \) and rewrite
Eq. \eqref{eq:deltaint} as   
$$
\begin{equation}
I_{\Delta}(x)={\cal P}\int_{-1}^{+1}ds\frac{f(\Delta s+x)}{s}.
\label{eq:deltaint2}
\end{equation}
$$
</div>
</div>


<p>
<!-- !split -->

<h2 id="___sec77" class="anchor">Treatment of Singular Integrals  </h2>
<div class="panel panel-default">
<div class="panel-body">
<p> <!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
The integration limits are now from \( -1 \) to \( 1 \), as for the Legendre
polynomials.
The principal value in Eq. \eqref{eq:deltaint2} is however rather tricky
to evaluate numerically, mainly since computers have limited
precision. We will here use a subtraction trick often used
when dealing with singular integrals in numerical calculations.
We introduce first the calculus relation
$$
\begin{equation*}
  \int_{-1}^{+1} \frac{ds}{s} =0.
\end{equation*}
$$

It means that the curve \( 1/(s) \) has equal and opposite
areas on both sides of the singular point \( s=0 \).
</div>
</div>


<p>
<!-- !split -->

<h2 id="___sec78" class="anchor">Treatment of Singular Integrals  </h2>
<div class="panel panel-default">
<div class="panel-body">
<p> <!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
If we then note that \( f(x) \) is just a constant, we have also
$$
\begin{equation*}
  f(x)\int_{-1}^{+1} \frac{ds}{s}=\int_{-1}^{+1}f(x) \frac{ds}{s} =0.
\end{equation*}
$$

<p>
Subtracting this equation from 
Eq. \eqref{eq:deltaint2} yields
$$
\begin{equation}
I_{\Delta}(x)={\cal P}\int_{-1}^{+1}ds\frac{f(\Delta s+x)}{s}=\int_{-1}^{+1}ds\frac{f(\Delta s+x)-f(x)}{s},
\label{eq:deltaint3}
\end{equation}
$$

and the integrand is no longer singular since we have that 
\( \lim_{s \rightarrow 0} (f(s+x) -f(x))=0 \) and for the particular case
\( s=0 \) the integrand 
is now finite.
</div>
</div>


<p>
<!-- !split -->

<h2 id="___sec79" class="anchor">Treatment of Singular Integrals  </h2>
<div class="panel panel-default">
<div class="panel-body">
<p> <!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
Eq. \eqref{eq:deltaint3} is now rewritten using the Gauss-Legendre
method resulting in
$$
\begin{equation}
\int_{-1}^{+1}ds\frac{f(\Delta s+x)-f(x)}{s}=\sum_{i=1}^{N}\omega_i\frac{f(\Delta s_i+x)-f(x)}{s_i},
\label{eq:deltaint4}
\end{equation}
$$

where \( s_i \) are the mesh points (\( N \) in total) and \( \omega_i \) are the weights.

<p>
In the selection of mesh points for  a PV integral, it is important
to use an even number of points, since an odd number of mesh
points always picks \( s_i=0 \) as one of the mesh points. The sum in
Eq. \eqref{eq:deltaint4} will then diverge.
</div>
</div>


<p>
<!-- !split -->

<h2 id="___sec80" class="anchor">Treatment of Singular Integrals  </h2>
<div class="panel panel-default">
<div class="panel-body">
<p> <!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
Let us apply this method to the integral
$$
\begin{equation}
I(x)={\cal P}\int_{-1}^{+1}dt\frac{e^t}{t}.
\label{eq:deltaint5}
\end{equation}
$$

The integrand diverges at \( x=t=0 \). We
rewrite it using Eq. \eqref{eq:deltaint3} as
$$
\begin{equation}
{\cal P}\int_{-1}^{+1}dt\frac{e^t}{t}=\int_{-1}^{+1}\frac{e^t-1}{t},
\label{eq:deltaint6}
\end{equation}
$$

since \( e^x=e^0=1 \). With Eq. \eqref{eq:deltaint4} we have then
$$
\begin{equation}
\int_{-1}^{+1}\frac{e^t-1}{t}\approx \sum_{i=1}^{N}\omega_i\frac{e^{t_i}-1}{t_i}.
\label{eq:deltaint7}
\end{equation}
$$
</div>
</div>


<p>
<!-- !split -->

<h2 id="___sec81" class="anchor">Treatment of Singular Integrals  </h2>
<div class="panel panel-default">
<div class="panel-body">
<p> <!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
The exact results is \( 2.11450175075.... \). With just two mesh points we recall
from the previous subsection that \( \omega_1=\omega_2=1 \) and that the mesh points are the zeros of \( L_2(x) \), namely \( x_1=-1/\sqrt{3} \) and 
\( x_2=1/\sqrt{3} \). Setting \( N=2 \) and inserting these values in the last
equation gives

$$
\begin{equation*}
   I_2(x=0)=\sqrt{3}\left(e^{1/\sqrt{3}}-e^{-1/\sqrt{3}}\right)=2.1129772845.
\end{equation*}
$$

With six mesh points we get even the exact result to the tenth digit

$$
\begin{equation*}
   I_6(x=0)=2.11450175075!
\end{equation*}
$$
</div>
</div>


<p>
<!-- !split -->

<h2 id="___sec82" class="anchor">Treatment of Singular Integrals  </h2>
<div class="panel panel-default">
<div class="panel-body">
<p> <!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
We can repeat the above subtraction trick  for more complicated
integrands.
First we modify the integration limits to \( \pm \infty \) and use the fact
that

$$
\begin{equation*}
  \int_{-\infty}^{\infty} \frac{dk}{k-k_0}=
  \int_{-\infty}^{0} \frac{dk}{k-k_0}+
  \int_{0}^{\infty} \frac{dk}{k-k_0} =0.
\end{equation*}
$$

A change of variable \( u=-k \) in the integral with limits from \( -\infty \) to \( 0 \) gives

$$
\begin{equation*}
  \int_{-\infty}^{\infty} \frac{dk}{k-k_0}=
  \int_{\infty}^{0} \frac{-du}{-u-k_0}+
  \int_{0}^{\infty} \frac{dk}{k-k_0}=  \int_{0}^{\infty} \frac{dk}{-k-k_0}+
  \int_{0}^{\infty} \frac{dk}{k-k_0}=0.
\end{equation*}
$$
</div>
</div>


<p>
<!-- !split -->

<h2 id="___sec83" class="anchor">Treatment of Singular Integrals  </h2>
<div class="panel panel-default">
<div class="panel-body">
<p> <!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
It means that the curve \( 1/(k-k_0) \) has equal and opposite
areas on both sides of the singular point \( k_0 \). If we break
the integral into one over positive \( k \) and one over 
negative \( k \), a change of variable \( k\rightarrow -k \) 
allows us to rewrite the last equation as

$$
\begin{equation*}
  \int_{0}^{\infty} \frac{dk}{k^2-k_0^2} =0.
\end{equation*}
$$
</div>
</div>


<p>
<!-- !split -->

<h2 id="___sec84" class="anchor">Treatment of Singular Integrals  </h2>
<div class="panel panel-default">
<div class="panel-body">
<p> <!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
We can use this to express a principal values integral
as
$$
\begin{equation}
  {\cal P}\int_{0}^{\infty} \frac{f(k)dk}{k^2-k_0^2} =
  \int_{0}^{\infty} \frac{(f(k)-f(k_0))dk}{k^2-k_0^2},
\label{eq:trick_pintegral}
\end{equation}
$$

where the right-hand side is no longer singular at 
\( k=k_0 \), it is proportional to the derivative \( df/dk \),
and can be evaluated numerically as any other integral.

<p>
Such a trick is often used when evaluating integral  equations.
</div>
</div>


<p>
<!-- !split -->

<h2 id="___sec85" class="anchor">Example of a multidimensional integral   </h2>
<div class="panel panel-default">
<div class="panel-body">
<p> <!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
Here we show an example of a multidimensional integral which appears in quantum mechanical calculations.

<p>
The ansatz for the wave function for two electrons is given by the product of two
\( 1s \) wave functions as 
$$
   \Psi({\bf r}_1,{\bf r}_2)  =   \exp{-(\alpha (r_1+r_2))}.
$$

The integral we need to solve is the quantum mechanical expectation value of the correlation
energy between two electrons, namely
$$
   I = \int_{-\infty}^{\infty} d{\bf r}_1d{\bf r}_2  \exp{-2(\alpha (r_1+r_2))}\frac{1}{|{\bf r}_1-{\bf r}_2|}.
$$

The integral has an exact solution \( 5\pi^2/16 = 0.19277 \).
</div>
</div>


<p>
<!-- !split -->

<h2 id="___sec86" class="anchor">Parts of code and brute force Gauss-Legendre quadrature  </h2>
<div class="panel panel-default">
<div class="panel-body">
<p> <!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
If we use Gaussian quadrature with Legendre polynomials (without rewriting the integral), we have
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span>     <span style="color: #B00040">double</span> <span style="color: #666666">*</span>x <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">new</span> <span style="color: #B00040">double</span> [N];
     <span style="color: #B00040">double</span> <span style="color: #666666">*</span>w <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">new</span> <span style="color: #B00040">double</span> [N];
<span style="color: #408080; font-style: italic">//   set up the mesh points and weights</span>
     GaussLegendrePoints(a,b,x,w, N);

<span style="color: #408080; font-style: italic">//   evaluate the integral with the Gauss-Legendre method</span>
<span style="color: #408080; font-style: italic">//   Note that we initialize the sum</span>
     <span style="color: #B00040">double</span> int_gauss <span style="color: #666666">=</span> <span style="color: #666666">0.</span>;
<span style="color: #408080; font-style: italic">//   six-double loops</span>
     <span style="color: #008000; font-weight: bold">for</span> (<span style="color: #B00040">int</span> i<span style="color: #666666">=0</span>;i<span style="color: #666666">&lt;</span>N;i<span style="color: #666666">++</span>){
	     <span style="color: #008000; font-weight: bold">for</span> (<span style="color: #B00040">int</span> j <span style="color: #666666">=</span> <span style="color: #666666">0</span>;j<span style="color: #666666">&lt;</span>N;j<span style="color: #666666">++</span>){
	     <span style="color: #008000; font-weight: bold">for</span> (<span style="color: #B00040">int</span> k <span style="color: #666666">=</span> <span style="color: #666666">0</span>;k<span style="color: #666666">&lt;</span>N;k<span style="color: #666666">++</span>){
	     <span style="color: #008000; font-weight: bold">for</span> (<span style="color: #B00040">int</span> l <span style="color: #666666">=</span> <span style="color: #666666">0</span>;l<span style="color: #666666">&lt;</span>N;l<span style="color: #666666">++</span>){
	     <span style="color: #008000; font-weight: bold">for</span> (<span style="color: #B00040">int</span> m <span style="color: #666666">=</span> <span style="color: #666666">0</span>;m<span style="color: #666666">&lt;</span>N;m<span style="color: #666666">++</span>){
	     <span style="color: #008000; font-weight: bold">for</span> (<span style="color: #B00040">int</span> n <span style="color: #666666">=</span> <span style="color: #666666">0</span>;n<span style="color: #666666">&lt;</span>N;n<span style="color: #666666">++</span>){
        int_gauss<span style="color: #666666">+=</span>w[i]<span style="color: #666666">*</span>w[j]<span style="color: #666666">*</span>w[k]<span style="color: #666666">*</span>w[l]<span style="color: #666666">*</span>w[m]<span style="color: #666666">*</span>w[n]
       <span style="color: #666666">*</span>int_function(x[i],x[j],x[k],x[l],x[m],x[n]);
     		}}}}}
	}
</pre></div>
<p>
</div>
</div>


<p>
<!-- !split -->

<h2 id="___sec87" class="anchor">The function to integrate, code example   </h2>
<div class="panel panel-default">
<div class="panel-body">
<p> <!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
<p>

<!-- code=c++ (!bc cppcod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span></span><span style="color: #408080; font-style: italic">//  this function defines the function to integrate</span>
<span style="color: #B00040">double</span> <span style="color: #0000FF">int_function</span>(<span style="color: #B00040">double</span> x1, <span style="color: #B00040">double</span> y1, <span style="color: #B00040">double</span> z1, <span style="color: #B00040">double</span> x2, <span style="color: #B00040">double</span> y2, <span style="color: #B00040">double</span> z2)
{
   <span style="color: #B00040">double</span> alpha <span style="color: #666666">=</span> <span style="color: #666666">2.</span>;
<span style="color: #408080; font-style: italic">// evaluate the different terms of the exponential</span>
   <span style="color: #B00040">double</span> exp1<span style="color: #666666">=-2*</span>alpha<span style="color: #666666">*</span>sqrt(x1<span style="color: #666666">*</span>x1<span style="color: #666666">+</span>y1<span style="color: #666666">*</span>y1<span style="color: #666666">+</span>z1<span style="color: #666666">*</span>z1);
   <span style="color: #B00040">double</span> exp2<span style="color: #666666">=-2*</span>alpha<span style="color: #666666">*</span>sqrt(x2<span style="color: #666666">*</span>x2<span style="color: #666666">+</span>y2<span style="color: #666666">*</span>y2<span style="color: #666666">+</span>z2<span style="color: #666666">*</span>z2);
   <span style="color: #B00040">double</span> deno<span style="color: #666666">=</span>sqrt(pow((x1<span style="color: #666666">-</span>x2),<span style="color: #666666">2</span>)<span style="color: #666666">+</span>pow((y1<span style="color: #666666">-</span>y2),<span style="color: #666666">2</span>)<span style="color: #666666">+</span>pow((z1<span style="color: #666666">-</span>z2),<span style="color: #666666">2</span>));
   <span style="color: #008000; font-weight: bold">return</span> exp(exp1<span style="color: #666666">+</span>exp2)<span style="color: #666666">/</span>deno;
} <span style="color: #408080; font-style: italic">// end of function to evaluate</span>
</pre></div>
<p>
</div>
</div>


<p>
<!-- !split -->

<h2 id="___sec88" class="anchor">Laguerre polynomials   </h2>
<div class="panel panel-default">
<div class="panel-body">
<p> <!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
Using Legendre polynomials for the Gaussian quadrature is not very efficient. There are several reasons for this:

<ul>
<li> You can easily end up in situations where the integrand diverges</li>
<li> The limits \( \pm \infty \) have to be approximated with a finite number</li>
</ul>

It is very useful here to change to spherical coordinates
$$
   d{\bf r}_1d{\bf r}_2  = r_1^2dr_1 r_2^2dr_2 dcos(\theta_1)dcos(\theta_2)d\phi_1d\phi_2,
$$

and
$$
   \frac{1}{r_{12}}= \frac{1}{\sqrt{r_1^2+r_2^2-2r_1r_2cos(\beta)}}
$$

with
$$
\cos(\beta) = \cos(\theta_1)\cos(\theta_2)+\sin(\theta_1)\sin(\theta_2)\cos(\phi_1-\phi_2))
$$
</div>
</div>


<p>
<!-- !split -->

<h2 id="___sec89" class="anchor">Laguerre polynomials, the new integrand   </h2>
<div class="panel panel-default">
<div class="panel-body">
<p> <!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
This means that our integral becomes
$$
I=\int_0^{\infty} r_1^2dr_1 \int_0^{\infty}r_2^2dr_2 \int_0^{\pi}dcos(\theta_1)\int_0^{\pi}dcos(\theta_2)\int_0^{2\pi}d\phi_1\int_0^{2\pi}d\phi_2  \frac{\exp{-2\alpha (r_1+r_2)}}{r_{12}}
$$

where we have defined
$$
   \frac{1}{r_{12}}= \frac{1}{\sqrt{r_1^2+r_2^2-2r_1r_2cos(\beta)}}
$$

with 
$$
\cos(\beta) = \cos(\theta_1)\cos(\theta_2)+\sin(\theta_1)\sin(\theta_2)\cos(\phi_1-\phi_2))
$$
</div>
</div>


<p>
<!-- !split -->

<h2 id="___sec90" class="anchor">Laguerre polynomials, new integration rule: Gauss-Laguerre   </h2>
<div class="panel panel-default">
<div class="panel-body">
<p> <!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
Our integral is now given by
$$
I=\int_0^{\infty} r_1^2dr_1 \int_0^{\infty}r_2^2dr_2 \int_0^{\pi}dcos(\theta_1)\int_0^{\pi}dcos(\theta_2)\int_0^{2\pi}d\phi_1\int_0^{2\pi}d\phi_2  \frac{\exp{-2\alpha (r_1+r_2)}}{r_{12}}
$$

For the angles we need to perform the integrations over \( \theta_i\in [0,\pi] \) and \( \phi_i \in [0,2\pi] \). However, for the radial part we can now either use

<ul>
<li> Gauss-Legendre wth an appropriate mapping or</li>
<li> Gauss-Laguerre taking properly care of the integrands involving the \( r_i^2 \exp{-(2\alpha r_i)} \) terms.</li>
</ul>
</div>
</div>


<p>
<!-- !split -->

<h2 id="___sec91" class="anchor">Results with  \( N=20 \) with Gauss-Legendre   </h2>

<p>

<div class="row">
  <div class="col-xs-5">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="center">\( r_{\mathrm{max}} \)</td> <td align="center"><b>  Integral </b></td> <td align="center"><b>   Error    </b></td> </tr>
</thead>
<tbody>
<tr><td align="center">   1.00                      </td> <td align="center">   0.161419805    </td> <td align="center">   0.0313459063    </td> </tr>
<tr><td align="center">   1.50                      </td> <td align="center">   0.180468967    </td> <td align="center">   0.012296744     </td> </tr>
<tr><td align="center">   2.00                      </td> <td align="center">   0.177065182    </td> <td align="center">   0.0157005292    </td> </tr>
<tr><td align="center">   2.50                      </td> <td align="center">   0.167970694    </td> <td align="center">   0.0247950165    </td> </tr>
<tr><td align="center">   3.00                      </td> <td align="center">   0.156139391    </td> <td align="center">   0.0366263199    </td> </tr>
</tbody>
    </table>
  </div> <!-- col-xs-5 -->
</div> <!-- cell row -->
<p>
<!-- !split -->

<h2 id="___sec92" class="anchor">Results for  \( r_{\mathrm{max}}=2 \) with Gauss-Legendre   </h2>

<p>

<div class="row">
  <div class="col-xs-3">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="center">\( N \)</td> <td align="center"><b>  Integral </b></td> <td align="center"><b>    Error    </b></td> </tr>
</thead>
<tbody>
<tr><td align="center">   10         </td> <td align="center">   0.129834248    </td> <td align="center">   0.0629314631     </td> </tr>
<tr><td align="center">   16         </td> <td align="center">   0.167860437    </td> <td align="center">   0.0249052742     </td> </tr>
<tr><td align="center">   20         </td> <td align="center">   0.177065182    </td> <td align="center">   0.0157005292     </td> </tr>
<tr><td align="center">   26         </td> <td align="center">   0.183543237    </td> <td align="center">   0.00922247353    </td> </tr>
<tr><td align="center">   30         </td> <td align="center">   0.185795624    </td> <td align="center">   0.00697008738    </td> </tr>
</tbody>
    </table>
  </div> <!-- col-xs-3 -->
</div> <!-- cell row -->
<p>
<!-- !split -->

<h2 id="___sec93" class="anchor">Results  with Gauss-Laguerre   </h2>

<p>

<div class="row">
  <div class="col-xs-3">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="center">\( N \)</td> <td align="center"><b>  Integral </b></td> <td align="center"><b>    Error     </b></td> </tr>
</thead>
<tbody>
<tr><td align="center">   10         </td> <td align="center">   0.186457345    </td> <td align="center">   0.00630836601     </td> </tr>
<tr><td align="center">   16         </td> <td align="center">   0.190113364    </td> <td align="center">   0.00265234708     </td> </tr>
<tr><td align="center">   20         </td> <td align="center">   0.19108178     </td> <td align="center">   0.00168393093     </td> </tr>
<tr><td align="center">   26         </td> <td align="center">   0.191831828    </td> <td align="center">   0.000933882594    </td> </tr>
<tr><td align="center">   30         </td> <td align="center">   0.192113712    </td> <td align="center">   0.000651999339    </td> </tr>
</tbody>
    </table>
  </div> <!-- col-xs-3 -->
</div> <!-- cell row -->
<p>
The code that was used to generate these results can be found under the <a href="https://github.com/CompPhysics/ComputationalPhysics/blob/master/doc/Programs/LecturePrograms/programs/NumericalIntegration/cpp/program2.cpp" target="_self">program link</a>.

<!-- ------------------- end of main content --------------- -->

</div>  <!-- end container -->
<!-- include javascript, jQuery *first* -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="https://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>

<!-- Bootstrap footer
<footer>
<a href="http://..."><img width="250" align=right src="http://..."></a>
</footer>
-->


<center style="font-size:80%">
<!-- copyright --> &copy; 1999-2018, Morten Hjorth-Jensen. Released under CC Attribution-NonCommercial 4.0 license
</center>


</body>
</html>
    

